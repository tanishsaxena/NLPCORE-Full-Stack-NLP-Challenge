{"title": "Assembly language", "authors": ["Oleg Alexandrov"], "time_published": "2020-01-26T19:22:37Z", "sections": [{"title": "", "paragraphs": "{{short description|Low level programming language}}\n{{Infobox programming language\n| name = <!-- otherwise defaults to {{PAGENAME}} -->\n| logo = <!-- (filename) -->\n| logo caption = \n| screenshot = File:Motorola 6800 Assembly Language.png\n| screenshot caption = Typical ''secondary output'' from an assembler&mdash;showing original assembly language (right) for the [[Motorola]] [[MC6800]] and the assembled form\n| paradigm = [[Imperative programming|Imperative]], [[Unstructured programming|unstructured]]\n| family = \n| designer = <!-- or: | designers = -->\n| developer = <!-- or: | developers = -->\n| released = {{start date and age|1949}}\n| latest release version = \n| latest release date = <!-- {{start date and age|YYYY|MM|DD|df=yes/no}} -->\n| latest preview version = \n| latest preview date = <!-- {{start date and age|YYYY|MM|DD|df=yes/no}} -->\n| typing = \n| scope = \n| programming language = \n| discontinued = \n| platform = \n| operating system = \n| license = \n| file ext = \n| file format = <!-- or: | file formats = -->\n| website = <!-- {{url|www.example.com}} -->\n| implementations = \n| dialects = \n| influenced by = \n| influenced = \n}}\nIn [[computer programming]],  '''assembly language''' (or '''assembler language'''),<ref name=ASM1>{{cite web\n|url=https://www.ibm.com/support/knowledgecenter/SSLTBW_2.1.0/com.ibm.zos.v2r1.asma400/asmr102112.htm\n|title=Assembler language}}</ref> often abbreviated '''asm''', is any [[low-level programming language]] in which there is a very strong correspondence between the instructions in the language and the [[computer architecture|architecture's]] [[machine code]] [[Instruction set architecture|instructions]].<ref>{{cite book |author1=James Saxon |author2=William Plette |title=Programming the IBM 1401 \n|url=https://babel.hathitrust.org/cgi/pt?id=mdp.39015000480718;view=2up;seq=6 \n|publisher=Prentice-Hall |year=1962 |lccn=62-20615 |via=HathiTrust}} [use of the term ''assembly program'']</ref> Because assembly depends on the machine code instructions, every assembler has its own assembly language which is designed for exactly one specific computer architecture. Assembly language may also be called ''symbolic machine code''.<ref>{{cite web  |date=2016\n|title=Assembly: Review \u2013 The Ohio State University\n|url=http://web.cse.ohio-state.edu/~sivilotti.1/teaching/3903.recent/lectures/lecture14.pdf}}</ref><ref>{{cite web |title=Assembly Language For Students |url=https://dl.acm.org/citation.cfm?id=3125846\n|author=B. Archer  \n|quote=Assembly language may also be called symbolic machine code.}}</ref>\n\nAssembly code is converted into executable machine code by a [[utility software|utility program]] referred to as an ''[[#Assembler|assembler]]''. The conversion process is referred to as ''assembly'', as in ''assembling'' the [[source code]]. Assembly language usually has one statement per machine instruction (1:1), but [[Comment (computer programming)|comments]] and statements that are assembler [[Directive (programming)|directives]],<ref name=A.DIR>{{cite web\n    |url=http://www.bixoft.nl/english/opcd00.htm\n    |title=High Level Assembler \u2013 Opcodes overview, Assembler Directives}}</ref> [[Macro instruction|macros]],<ref>{{cite web  |title=Macro instructions\n|url=https://www.ibm.com/support/knowledgecenter/en/SSLTBW_2.1.0/com.ibm.zos.v2r1.asma400/asmr102115.htm}}</ref><ref name=ASM1/> and symbolic [[Label (programming)|labels of program]] and [[Memory location|memory locations]] are often also supported.\n\nEach assembly language is specific to a particular [[computer architecture]] and sometimes to an [[operating system]].<ref>System calls often vary, e.g. for [[OS/360 and successors|MVS]] vs. [[DOS/360 and successors|VSE]] vs. VM/CMS; the binary/executable formats for different operating systems may also vary. {{cite web\n|url=https://stackoverflow.com/questions/6859348/how-do-assembly-languages-depend-on-operating-systems\n|title=How do assembly languages depend on operating systems?}}</ref> However, some assembly languages do not provide specific [[Syntax (programming languages)|syntax]] for operating system calls, and most assembly languages can be used universally with any operating system, as the language provides access to all the real capabilities of the [[Computer processor|processor]], upon which all [[system call]] mechanisms ultimately rest. In contrast to assembly languages, most [[high-level programming language]]s are generally [[porting|portable]] across multiple architectures but require [[Interpreter (computing)|interpreting]] or [[Compiler|compiling]], a much more complicated task than assembling.\n\n", "attributes": [{"name": "short description", "values": [{"name": "1", "value": "Low level programming language"}]}, {"name": "Infobox programming language\n", "values": [{"name": "name", "value": "<!-- otherwise defaults to {{PAGENAME}} -->"}, {"name": "logo", "value": "<!-- (filename) -->"}, {"name": "screenshot", "value": "File:Motorola 6800 Assembly Language.png"}, {"name": "screenshot caption", "value": "Typical ''secondary output'' from an assembler&mdash;showing original assembly language (right) for the [[Motorola]] [[MC6800]] and the assembled form"}, {"name": "paradigm", "value": "[[Imperative programming|Imperative]], [[Unstructured programming|unstructured]]"}, {"name": "designer", "value": "<!-- or: | designers = -->"}, {"name": "developer", "value": "<!-- or: | developers = -->"}, {"name": "released", "value": "{{start date and age|1949}}"}, {"name": "latest release date", "value": "<!-- {{start date and age|YYYY|MM|DD|df=yes/no}} -->"}, {"name": "latest preview date", "value": "<!-- {{start date and age|YYYY|MM|DD|df=yes/no}} -->"}, {"name": "file format", "value": "<!-- or: | file formats = -->"}, {"name": "website", "value": "<!-- {{url|www.example.com}} -->"}]}, {"name": "start date and age", "values": [{"name": "1", "value": "1949"}]}, {"name": "cite web\n", "values": [{"name": "url", "value": "https://www.ibm.com/support/knowledgecenter/SSLTBW_2.1.0/com.ibm.zos.v2r1.asma400/asmr102112.htm"}, {"name": "title", "value": "Assembler language"}]}, {"name": "cite book ", "values": [{"name": "author1", "value": "James Saxon"}, {"name": "author2", "value": "William Plette"}, {"name": "title", "value": "Programming the IBM 1401"}, {"name": "url", "value": "https://babel.hathitrust.org/cgi/pt?id=mdp.39015000480718;view=2up;seq=6"}, {"name": "publisher", "value": "Prentice-Hall"}, {"name": "year", "value": "1962"}, {"name": "lccn", "value": "62-20615"}, {"name": "via", "value": "HathiTrust"}]}, {"name": "cite web  ", "values": [{"name": "date", "value": "2016"}, {"name": "title", "value": "Assembly: Review \u2013 The Ohio State University"}, {"name": "url", "value": "http://web.cse.ohio-state.edu/~sivilotti.1/teaching/3903.recent/lectures/lecture14.pdf"}]}, {"name": "cite web ", "values": [{"name": "title", "value": "Assembly Language For Students"}, {"name": "url", "value": "https://dl.acm.org/citation.cfm?id=3125846"}, {"name": "author", "value": "B. Archer"}, {"name": "quote", "value": "Assembly language may also be called symbolic machine code."}]}, {"name": "cite web\n    ", "values": [{"name": "url", "value": "http://www.bixoft.nl/english/opcd00.htm"}, {"name": "title", "value": "High Level Assembler \u2013 Opcodes overview, Assembler Directives"}]}, {"name": "cite web  ", "values": [{"name": "title", "value": "Macro instructions"}, {"name": "url", "value": "https://www.ibm.com/support/knowledgecenter/en/SSLTBW_2.1.0/com.ibm.zos.v2r1.asma400/asmr102115.htm"}]}, {"name": "cite web\n", "values": [{"name": "url", "value": "https://stackoverflow.com/questions/6859348/how-do-assembly-languages-depend-on-operating-systems"}, {"name": "title", "value": "How do assembly languages depend on operating systems?"}]}], "id": 0}, {"title": "Assembly language syntax", "paragraphs": "Assembly language uses a [[mnemonic]] to represent each low-level [[machine code|machine instruction]] or [[opcode]], typically also each [[register (computing)#ARCHITECTURAL|architectural register]], [[bit field|flag]], etc. Many operations require one or more [[Operand#Computer science|operands]] in order to form a complete instruction. Most assemblers permit named constants, registers, and [[Label (computer science)|labels]] for program and memory locations, and can calculate [[Expression (computer science)|expressions]] for operands. Thus, the programmers are freed from tedious repetitive calculations and assembler programs are much more readable than machine code. Depending on the architecture, these elements may also be combined for specific instructions or [[addressing mode]]s using [[offset (computer science)|offset]]s or other data as well as fixed addresses. Many assemblers offer additional mechanisms to facilitate program development, to control the assembly process, and to aid [[debugging]].\n\n", "attributes": [], "id": 1}, {"title": "Terminology", "paragraphs": "* A '''macro assembler''' includes a [[macro (computer science)|macroinstruction]] facility so that (parameterized) assembly language text can be represented by a name, and that name can be used to insert the expanded text into other code.\n* {{anchor|Cross assembler}}A '''cross assembler''' (see also [[cross compiler]]) is an assembler that is run on a computer or [[operating system]] (the ''host'' system) of a different type from the system on which the resulting code is to run (the ''target system''). Cross-assembling facilitates the development of programs for systems that do not have the resources to support software development, such as an [[embedded system]] or a [[microcontroller]]. In such a case, the resulting [[object code]] must be transferred to the target system, via [[read-only memory]] (ROM, [[EPROM]], etc.), a [[Programmer_(hardware)|programmer]] (when the read-only memory is integrated in the device, as in microcontrollers), or a data link using either an exact bit-by-bit copy of the object code or a text-based representation of that code (such as [[SREC (file format)|Motorola S-record]] or [[Intel HEX]]).\n* A '''[[high-level assembler]]''' is a program that provides language abstractions more often associated with high-level languages, such as advanced control structures ([[If-then-else|IF/THEN/ELSE]], DO CASE, etc.) and high-level abstract data types, including structures/records, unions, classes, and sets.\n* A '''[[microassembler]]''' is a program that helps prepare a [[microcode|microprogram]], called ''firmware'', to control the low level operation of a computer.\n* A '''meta-assembler''' is a term used in some circles for ''\"a program that accepts the syntactic and semantic description of an assembly language, and generates an assembler for that language.\"''<ref>[http://www.encyclopedia.com/doc/1O11-metaassembler.html (John Daintith, ed.) A Dictionary of Computing: \"meta-assembler\"]</ref>\n* ''Assembly time'' is the computational step where an assembler is run.\n\n", "attributes": [{"name": "anchor", "values": [{"name": "1", "value": "Cross assembler"}]}], "id": 2}, {"title": "Key concepts", "paragraphs": "===Assembler===<!-- This section is linked from [[Computer software]] -->\nAn '''assembler''' program creates [[object code]] by translating combinations of mnemonics and [[syntax]] for operations and addressing modes into their numerical equivalents. This representation typically includes an ''operation code'' (\"[[opcode]]\") as well as other control [[bit]]s and data. The assembler also calculates constant expressions and resolves [[identifier|symbolic names]] for memory locations and other entities.<ref name=\"Salomon\">David Salomon (1993). ''[http://www.davidsalomon.name/assem.advertis/asl.pdf Assemblers and Loaders]''</ref> The use of symbolic references is a key feature of assemblers, saving tedious calculations and manual address updates after program modifications. Most assemblers also include [[Macro (computer science)|macro]] facilities for performing textual substitution \u2013 e.g., to generate common short sequences of instructions as [[inline expansion|inline]], instead of ''called'' [[subroutine]]s.\n\nSome assemblers may also be able to perform some simple types of [[instruction set]]-specific [[Compiler optimization|optimizations]]. One concrete example of this may be the ubiquitous [[x86]] assemblers from various vendors. Most of them are able to perform jump-instruction replacements (long jumps replaced by short or relative jumps) in any number of passes, on request. Others may even do simple rearrangement or insertion of instructions, such as some assemblers for [[RISC]] [[Instruction set architecture|architectures]] that can help optimize a sensible [[instruction scheduling]] to exploit the [[CPU pipeline]] as efficiently as possible.{{citation needed|date=November 2011}}\n\nLike early programming languages such as [[Fortran]], [[ALGOL|Algol]], [[Cobol]] and [[Lisp (programming language)|Lisp]], assemblers have been available since the 1950s and the first generations of text based [[computer interface]]s. However, assemblers came first as they are far simpler to write than [[compiler]]s for [[high-level language]]s. This is because each mnemonic along with the addressing modes and operands of an instruction translates rather directly into the numeric representations of that particular instruction, without much context or analysis. There have also been several classes of translators and semi automatic [[code generator]]s with properties similar to both assembly and [[high level language]]s, with [[Speedcode]] as perhaps one of the better known examples.\n\nThere may be several assemblers with different [[Syntax (programming languages)|syntax]] for a particular [[Central processing unit|CPU]] or [[instruction set architecture]]. For instance, an instruction to add memory data to a register in a [[x86]]-family processor might be <code>add eax,[ebx]</code>, in original ''[[Intel syntax]]'', whereas this would be written <code>addl (%ebx),%eax</code> in the ''[[AT&T syntax]]'' used by the [[GNU Assembler]]. Despite different appearances, different syntactic forms generally generate the same numeric [[machine code]]. See below. A single assembler may also have different modes in order to support variations in syntactic forms as well as their exact semantic interpretations (such as [[FASM]]-syntax, [[TASM]]-syntax, ideal mode, etc., in the special case of [[X86 assembly language|x86 assembly]] programming).\n\n==== {{Anchor|Two-pass assembler}} Number of passes====\nThere are two types of assemblers based on how many passes through the source are needed  (how many times the assembler reads the source) to produce the object file.\n* '''One-pass assemblers''' go through the source code once. Any symbol used before it is defined will require [[Erratum|\"errata\"]] at the end of the object code (or, at least, no earlier than the point where the symbol is defined) telling the [[linker (computing)|linker]] or the loader to \"go back\" and overwrite a placeholder which had been left where the as yet undefined symbol was used.\n* '''Multi-pass assemblers''' create a table with all symbols and their values in the first passes, then use the table in later passes to generate code.\nIn both cases, the assembler must be able to determine the size of each instruction on the initial passes in order to calculate the addresses of subsequent symbols. This means that if the size of an operation referring to an operand defined later depends on the type or distance of the operand, the assembler will make a pessimistic estimate when first encountering the operation, and if necessary, pad it with one or more\n\"[[NOP (code)|no-operation]]\" instructions in a later pass or the errata. In an assembler with [[peephole optimization]], addresses may be recalculated between passes to allow replacing pessimistic code with code tailored to the exact distance from the target.\n\nThe original reason for the use of one-pass assemblers was speed of assembly \u2013 often a second pass would require rewinding and rereading the program source on [[Magnetic tape data storage|tape]] or rereading a deck of [[Punch cards|cards]] or [[Punched tape|punched paper tape]]. Later computers with much larger memories (especially disc storage), had the space to perform all necessary processing without such re-reading. The advantage of the multi-pass assembler is that the absence of errata makes the [[Linker (computing)|linking process]] (or the [[Loader (computing)|program load]] if the assembler directly produces executable code) faster.<ref>{{Cite book|last=Beck|first=Leland L.|title=System Software: An Introduction to Systems Programming|publisher=Addison Wesley|year=1996|chapter=2}}</ref>\n\n'''Example:''' in the following code snippet, a one-pass assembler would be able to determine the address of the backward reference <var>BKWD</var> when assembling statement <var>S2</var>, but would not be able to determine the address of the forward reference <var>FWD</var> when assembling the branch statement <var>S1</var>; indeed, <var>FWD</var> may be undefined. A two-pass assembler would determine both addresses in pass 1, so they would be known when generating code in pass 2.\n {{var|S1}}   B    {{var|FWD}}\n   ...\n {{var|FWD}}   EQU *\n   ...\n {{var|BKWD}}  EQU *\n   ...\n {{var|S2}}    B   {{var|BKWD}}\n\n====High-level assemblers====\nMore sophisticated [[high-level assembler]]s provide language abstractions such as:\n* High-level procedure/function declarations and invocations\n* Advanced control structures (IF/THEN/ELSE, SWITCH)\n* High-level abstract data types, including structures/records, unions, classes, and sets\n* Sophisticated macro processing (although available on ordinary assemblers since the late 1950s for [[IBM 700/7000 series|IBM 700 series]] and since the 1960s for [[IBM/360]], amongst other machines)\n* [[Object-oriented programming]] features such as [[class (computer programming)|classes]], [[Object (computer science)|objects]], [[Abstraction (computer science)|abstraction]], [[type polymorphism|polymorphism]], and [[inheritance (object-oriented programming)|inheritance]]<ref>Hyde, Randall. \"Chapter 12 \u2013 Classes and Objects\". The Art of Assembly Language, 2nd Edition. No Starch Press. \u00a9 2010.</ref>\nSee [[#Language design|Language design]] below for more details.\n\n===Assembly language===\nA program written in assembly language consists of a series of [[mnemonic]] processor instructions and meta-statements (known variously as directives, pseudo-instructions and pseudo-ops), comments and data. Assembly language instructions usually consist of an [[opcode]] mnemonic followed by a list of data, arguments or parameters.<ref name=\"intel-1999\">{{cite book |title=Intel Architecture Software Developer's Manual, Volume 2: Instruction Set Reference |year=1999 |publisher=Intel Corporation |url=http://download.intel.com/design/PentiumII/manuals/24319102.PDF |accessdate=18 November 2010}}</ref> These are translated by an [[Assembly language assembler|assembler]] into [[machine language]] instructions that can be loaded into memory and executed.\n\nFor example, the instruction below tells an [[x86]]/[[IA-32]] processor to move an [[Constant (programming)|immediate 8-bit value]] into a [[processor register|register]]. The binary code for this instruction is 10110 followed by a 3-bit identifier for which register to use. The identifier for the ''AL'' register is 000, so the following [[machine code]] loads the ''AL'' register with the data 01100001.<ref name=\"intel-1999-MOV\">{{cite book |title=Intel Architecture Software Developer's Manual, Volume 2: Instruction Set Reference |year=1999 |publisher=Intel Corporation |pages=442 and 35|url=http://download.intel.com/design/PentiumII/manuals/24319102.PDF|accessdate=18 November 2010}}</ref>\n 10110000 01100001\nThis binary computer code can be made more human-readable by expressing it in [[hexadecimal]] as follows.\n B0 61\nHere, <code>B0</code> means 'Move a copy of the following value into ''AL'', and <code>61</code> is a hexadecimal representation of the value 01100001, which is 97 in [[decimal]]. Assembly language for the 8086 family provides the [[mnemonic]] [[MOV (x86 instruction)|MOV]] (an abbreviation of ''move'') for instructions such as this, so the machine code above can be written as follows in assembly language, complete with an explanatory comment if required, after the semicolon. This is much easier to read and to remember.\n<syntaxhighlight lang=\"nasm\">MOV AL, 61h       ; Load AL with 97 decimal (61 hex)</syntaxhighlight>\n\nIn some assembly languages (including this one) the same mnemonic, such as MOV, may be used for a family of related instructions for loading, copying and moving data, whether these are immediate values, values in registers, or memory locations pointed to by values in registers or by immediate (a/k/a direct) addresses.  Other assemblers may use separate opcode mnemonics such as L for \"move memory to register\", ST for \"move register to memory\", LR for \"move register to register\", MVI for \"move immediate operand to memory\", etc.\n\nIf the same mnemonic is used for different instructions, that means that the mnemonic corresponds to several different binary instruction codes, excluding data (e.g. the <code>61h</code> in this example), depending on the operands that follow the mnemonic.  For example, for the x86/IA-32 CPUs, the Intel assembly language syntax <code>MOV AL, AH</code> represents an instruction that moves the contents of register ''AH'' into register ''AL''.  The<ref>Actually, this is one of two redundant forms of this instruction that operate identically.  The 8086 and several other CPUs from the late 1970s/early 1980s have redundancies in their instruction sets, because it was simpler for engineers to design these CPUs (to fit on silicon chips of limited sizes) with the redundant codes than to eliminate them.  Each assembler will typically generate only one of two or more redundant instruction encodings, but a ''disassembler'' will usually recognize any of them.</ref> hexadecimal form of this instruction is:\n 88 E0\nThe first byte, 88h, identifies a move between a byte-sized register and either another register or memory, and the second byte, E0h, is encoded (with three bit-fields) to specify that both operands are registers, the source is ''AH'', and the destination is ''AL''.\n\nIn a case like this where the same mnemonic can represent more than one binary instruction, the assembler determines which instruction to generate by examining the operands.  In the first example, the operand <code>61h</code> is a valid hexadecimal numeric constant and is not a valid register name, so only the <code>B0</code> instruction can be applicable.  In the second example, the operand <code>AH</code> is a valid register name and not a valid numeric constant (hexadecimal, decimal, octal, or binary), so only the <code>88</code> instruction can be applicable.\n\nAssembly languages are always designed so that this sort of unambiguousness is universally enforced by their syntax.  For example, in the Intel x86 assembly language, a hexadecimal constant must start with a numeral digit, so that the hexadecimal number 'A' (equal to decimal ten) would be written as <code>0Ah</code> or <code>0AH</code>, not <code>AH</code>, specifically so that it cannot appear to be the name of register ''AH''.  (The same rule also prevents ambiguity with the names of registers ''BH'', ''CH'', and ''DH'', as well as with any user-defined symbol that ends with the letter ''H'' and otherwise contains only characters that are hexadecimal digits, such as the word \"BEACH\".)\n\nReturning to the original example, while the x86 opcode 10110000 (<code>B0</code>) copies an 8-bit value into the ''AL'' register, 10110001 (<code>B1</code>) moves it into ''CL'' and 10110010 (<code>B2</code>) does so into ''DL''. Assembly language examples for these follow.<ref name=\"intel-1999-MOV\"/>\n<syntaxhighlight lang=\"nasm\">\nMOV AL, 1h        ; Load AL with immediate value 1\nMOV CL, 2h        ; Load CL with immediate value 2\nMOV DL, 3h        ; Load DL with immediate value 3\n</syntaxhighlight>\nThe syntax of MOV can also be more complex as the following examples show.<ref>{{cite web|last=Evans|first=David|title=x86 Assembly Guide|url=http://www.cs.virginia.edu/~evans/cs216/guides/x86.html|publisher=University of Virginia|accessdate=18 November 2010|year=2006}}</ref>\n<syntaxhighlight lang=\"nasm\">\nMOV EAX, [EBX]\t  ; Move the 4 bytes in memory at the address contained in EBX into EAX\nMOV [ESI+EAX], CL ; Move the contents of CL into the byte at address ESI+EAX\nMOV DS, DX        ; Move the contents of DX into segment register DS\n</syntaxhighlight>\n<!-- The MOV to/from segment register opcodes are included below, so an example involving a segment register should be included. -->\nIn each case, the MOV mnemonic is translated directly into one of the opcodes 88-8C, 8E, A0-A3, B0-BF, C6 or C7 by an assembler, and the programmer normally does not have to know or remember which.<ref name=\"intel-1999-MOV\"/>\n\nTransforming assembly language into machine code is the job of an assembler, and the reverse can at least partially be achieved by a [[disassembler]]. Unlike [[high-level language]]s, there is a [[one-to-one correspondence]] between many simple assembly statements and machine language instructions. However, in some cases, an assembler may provide ''pseudoinstructions'' (essentially macros) which expand into several machine language instructions to provide commonly needed functionality. For example, for a machine that lacks a \"branch if greater or equal\" instruction, an assembler may provide a pseudoinstruction that expands to the machine's \"set if less than\" and \"branch if zero (on the result of the set instruction)\". Most full-featured assemblers also provide a rich [[macro (computer science)|macro]] language (discussed below) which is used by vendors and programmers to generate more complex code and data sequences. Since the information about pseudoinstructions and macros defined in the assembler environment is not present in the object program, a disassembler cannot reconstruct the macro and pseudoinstruction invocations but can only disassemble the actual machine instructions that the assembler generated from those abstract assembly-language entities. Likewise, since comments in the assembly language source file are ignored by the assembler and have no effect on the object code it generates, a disassembler is always completely unable to recover source comments.\n\nEach [[computer architecture]] has its own machine language.  Computers differ in the number and type of operations they support, in the different sizes and numbers of registers, and in the representations of data in storage. While most general-purpose computers are able to carry out essentially the same functionality, the ways they do so differ; the corresponding assembly languages reflect these differences.\n\nMultiple sets of [[mnemonic]]s or assembly-language syntax may exist for a single instruction set, typically instantiated in different assembler programs. In these cases, the most popular one is usually that supplied by the CPU manufacturer and used in its documentation.\n\nTwo examples of CPUs that have two different sets of mnemonics are the Intel 8080 family and the Intel 8086/8088.  Because Intel claimed copyright on its assembly language mnemonics (on each page of their documentation published in the 1970s and early 1980s, at least), some companies that independently produced CPUs compatible with Intel instruction sets invented their own mnemonics.  The Zilog Z80 CPU, an enhancement of the Intel 8080A, supports all the 8080A instructions plus many more; Zilog invented an entirely new assembly language, not only for the new instructions but also for all of the 8080A instructions.  For example, where Intel uses the mnemonics ''MOV'', ''MVI'', ''LDA'', ''STA'', ''LXI'', ''LDAX'', ''STAX'', ''LHLD'', and ''SHLD'' for various data transfer instructions, the Z80 assembly language uses the mnemonic ''LD'' for all of them.  A similar case is the NEC V30 and V20 CPUs, enhanced copies of the Intel 8086 and 8088, respectively.  Like Zilog with the Z80, NEC invented new mnemonics for all of the 8086 and 8088 instructions, to avoid accusations of infringement of Intel's copyright.  (It is questionable whether such copyrights can be valid, and later CPU companies such as AMD<ref>Note: AMD manufactured second-source Intel 8086, 8088, and 80286 CPUs, and perhaps 8080A and/or 8085A CPUs, under license from Intel, but starting with the 80386, Intel refused to share their x86 CPU designs with anyone&mdash;AMD sued about this for breach of contract&mdash;and AMD designed, made, and sold 32-bit and 64-bit x86-family CPUs without Intel's help or endorsement.</ref> and Cyrix republished Intel's x86/IA-32 instruction mnemonics exactly with neither permission nor legal penalty.)  It is doubtful whether in practice many people who programmed the V20 and V30 actually wrote in NEC's assembly language rather than Intel's; since any two assembly languages for the same instruction set architecture are isomorphic (somewhat like English and Pig Latin), there is no requirement to use a manufacturer's own published assembly language with that manufacturer's products.\n\n", "attributes": [{"name": "citation needed", "values": [{"name": "date", "value": "November 2011"}]}, {"name": "Anchor", "values": [{"name": "1", "value": "Two-pass assembler"}]}, {"name": "Cite book", "values": [{"name": "last", "value": "Beck"}, {"name": "first", "value": "Leland L."}, {"name": "title", "value": "System Software: An Introduction to Systems Programming"}, {"name": "publisher", "value": "Addison Wesley"}, {"name": "year", "value": "1996"}, {"name": "chapter", "value": "2"}]}, {"name": "var", "values": [{"name": "1", "value": "S1"}]}, {"name": "var", "values": [{"name": "1", "value": "FWD"}]}, {"name": "var", "values": [{"name": "1", "value": "FWD"}]}, {"name": "var", "values": [{"name": "1", "value": "BKWD"}]}, {"name": "var", "values": [{"name": "1", "value": "S2"}]}, {"name": "var", "values": [{"name": "1", "value": "BKWD"}]}, {"name": "cite book ", "values": [{"name": "title", "value": "Intel Architecture Software Developer's Manual, Volume 2: Instruction Set Reference"}, {"name": "year", "value": "1999"}, {"name": "publisher", "value": "Intel Corporation"}, {"name": "url", "value": "http://download.intel.com/design/PentiumII/manuals/24319102.PDF"}, {"name": "accessdate", "value": "18 November 2010"}]}, {"name": "cite book ", "values": [{"name": "title", "value": "Intel Architecture Software Developer's Manual, Volume 2: Instruction Set Reference"}, {"name": "year", "value": "1999"}, {"name": "publisher", "value": "Intel Corporation"}, {"name": "pages", "value": "442 and 35"}, {"name": "url", "value": "http://download.intel.com/design/PentiumII/manuals/24319102.PDF"}, {"name": "accessdate", "value": "18 November 2010"}]}, {"name": "cite web", "values": [{"name": "last", "value": "Evans"}, {"name": "first", "value": "David"}, {"name": "title", "value": "x86 Assembly Guide"}, {"name": "url", "value": "http://www.cs.virginia.edu/~evans/cs216/guides/x86.html"}, {"name": "publisher", "value": "University of Virginia"}, {"name": "accessdate", "value": "18 November 2010"}, {"name": "year", "value": "2006"}]}], "id": 3}, {"title": "Assembler", "paragraphs": "An '''assembler''' program creates [[object code]] by translating combinations of mnemonics and [[syntax]] for operations and addressing modes into their numerical equivalents. This representation typically includes an ''operation code'' (\"[[opcode]]\") as well as other control [[bit]]s and data. The assembler also calculates constant expressions and resolves [[identifier|symbolic names]] for memory locations and other entities.<ref name=\"Salomon\">David Salomon (1993). ''[http://www.davidsalomon.name/assem.advertis/asl.pdf Assemblers and Loaders]''</ref> The use of symbolic references is a key feature of assemblers, saving tedious calculations and manual address updates after program modifications. Most assemblers also include [[Macro (computer science)|macro]] facilities for performing textual substitution \u2013 e.g., to generate common short sequences of instructions as [[inline expansion|inline]], instead of ''called'' [[subroutine]]s.\n\nSome assemblers may also be able to perform some simple types of [[instruction set]]-specific [[Compiler optimization|optimizations]]. One concrete example of this may be the ubiquitous [[x86]] assemblers from various vendors. Most of them are able to perform jump-instruction replacements (long jumps replaced by short or relative jumps) in any number of passes, on request. Others may even do simple rearrangement or insertion of instructions, such as some assemblers for [[RISC]] [[Instruction set architecture|architectures]] that can help optimize a sensible [[instruction scheduling]] to exploit the [[CPU pipeline]] as efficiently as possible.{{citation needed|date=November 2011}}\n\nLike early programming languages such as [[Fortran]], [[ALGOL|Algol]], [[Cobol]] and [[Lisp (programming language)|Lisp]], assemblers have been available since the 1950s and the first generations of text based [[computer interface]]s. However, assemblers came first as they are far simpler to write than [[compiler]]s for [[high-level language]]s. This is because each mnemonic along with the addressing modes and operands of an instruction translates rather directly into the numeric representations of that particular instruction, without much context or analysis. There have also been several classes of translators and semi automatic [[code generator]]s with properties similar to both assembly and [[high level language]]s, with [[Speedcode]] as perhaps one of the better known examples.\n\nThere may be several assemblers with different [[Syntax (programming languages)|syntax]] for a particular [[Central processing unit|CPU]] or [[instruction set architecture]]. For instance, an instruction to add memory data to a register in a [[x86]]-family processor might be <code>add eax,[ebx]</code>, in original ''[[Intel syntax]]'', whereas this would be written <code>addl (%ebx),%eax</code> in the ''[[AT&T syntax]]'' used by the [[GNU Assembler]]. Despite different appearances, different syntactic forms generally generate the same numeric [[machine code]]. See below. A single assembler may also have different modes in order to support variations in syntactic forms as well as their exact semantic interpretations (such as [[FASM]]-syntax, [[TASM]]-syntax, ideal mode, etc., in the special case of [[X86 assembly language|x86 assembly]] programming).\n\n==== {{Anchor|Two-pass assembler}} Number of passes====\nThere are two types of assemblers based on how many passes through the source are needed  (how many times the assembler reads the source) to produce the object file.\n* '''One-pass assemblers''' go through the source code once. Any symbol used before it is defined will require [[Erratum|\"errata\"]] at the end of the object code (or, at least, no earlier than the point where the symbol is defined) telling the [[linker (computing)|linker]] or the loader to \"go back\" and overwrite a placeholder which had been left where the as yet undefined symbol was used.\n* '''Multi-pass assemblers''' create a table with all symbols and their values in the first passes, then use the table in later passes to generate code.\nIn both cases, the assembler must be able to determine the size of each instruction on the initial passes in order to calculate the addresses of subsequent symbols. This means that if the size of an operation referring to an operand defined later depends on the type or distance of the operand, the assembler will make a pessimistic estimate when first encountering the operation, and if necessary, pad it with one or more\n\"[[NOP (code)|no-operation]]\" instructions in a later pass or the errata. In an assembler with [[peephole optimization]], addresses may be recalculated between passes to allow replacing pessimistic code with code tailored to the exact distance from the target.\n\nThe original reason for the use of one-pass assemblers was speed of assembly \u2013 often a second pass would require rewinding and rereading the program source on [[Magnetic tape data storage|tape]] or rereading a deck of [[Punch cards|cards]] or [[Punched tape|punched paper tape]]. Later computers with much larger memories (especially disc storage), had the space to perform all necessary processing without such re-reading. The advantage of the multi-pass assembler is that the absence of errata makes the [[Linker (computing)|linking process]] (or the [[Loader (computing)|program load]] if the assembler directly produces executable code) faster.<ref>{{Cite book|last=Beck|first=Leland L.|title=System Software: An Introduction to Systems Programming|publisher=Addison Wesley|year=1996|chapter=2}}</ref>\n\n'''Example:''' in the following code snippet, a one-pass assembler would be able to determine the address of the backward reference <var>BKWD</var> when assembling statement <var>S2</var>, but would not be able to determine the address of the forward reference <var>FWD</var> when assembling the branch statement <var>S1</var>; indeed, <var>FWD</var> may be undefined. A two-pass assembler would determine both addresses in pass 1, so they would be known when generating code in pass 2.\n {{var|S1}}   B    {{var|FWD}}\n   ...\n {{var|FWD}}   EQU *\n   ...\n {{var|BKWD}}  EQU *\n   ...\n {{var|S2}}    B   {{var|BKWD}}\n\n====High-level assemblers====\nMore sophisticated [[high-level assembler]]s provide language abstractions such as:\n* High-level procedure/function declarations and invocations\n* Advanced control structures (IF/THEN/ELSE, SWITCH)\n* High-level abstract data types, including structures/records, unions, classes, and sets\n* Sophisticated macro processing (although available on ordinary assemblers since the late 1950s for [[IBM 700/7000 series|IBM 700 series]] and since the 1960s for [[IBM/360]], amongst other machines)\n* [[Object-oriented programming]] features such as [[class (computer programming)|classes]], [[Object (computer science)|objects]], [[Abstraction (computer science)|abstraction]], [[type polymorphism|polymorphism]], and [[inheritance (object-oriented programming)|inheritance]]<ref>Hyde, Randall. \"Chapter 12 \u2013 Classes and Objects\". The Art of Assembly Language, 2nd Edition. No Starch Press. \u00a9 2010.</ref>\nSee [[#Language design|Language design]] below for more details.\n\n", "attributes": [{"name": "citation needed", "values": [{"name": "date", "value": "November 2011"}]}, {"name": "Anchor", "values": [{"name": "1", "value": "Two-pass assembler"}]}, {"name": "Cite book", "values": [{"name": "last", "value": "Beck"}, {"name": "first", "value": "Leland L."}, {"name": "title", "value": "System Software: An Introduction to Systems Programming"}, {"name": "publisher", "value": "Addison Wesley"}, {"name": "year", "value": "1996"}, {"name": "chapter", "value": "2"}]}, {"name": "var", "values": [{"name": "1", "value": "S1"}]}, {"name": "var", "values": [{"name": "1", "value": "FWD"}]}, {"name": "var", "values": [{"name": "1", "value": "FWD"}]}, {"name": "var", "values": [{"name": "1", "value": "BKWD"}]}, {"name": "var", "values": [{"name": "1", "value": "S2"}]}, {"name": "var", "values": [{"name": "1", "value": "BKWD"}]}], "id": 4}, {"title": " {{Anchor|Two-pass assembler}} Number of passes", "paragraphs": "There are two types of assemblers based on how many passes through the source are needed  (how many times the assembler reads the source) to produce the object file.\n* '''One-pass assemblers''' go through the source code once. Any symbol used before it is defined will require [[Erratum|\"errata\"]] at the end of the object code (or, at least, no earlier than the point where the symbol is defined) telling the [[linker (computing)|linker]] or the loader to \"go back\" and overwrite a placeholder which had been left where the as yet undefined symbol was used.\n* '''Multi-pass assemblers''' create a table with all symbols and their values in the first passes, then use the table in later passes to generate code.\nIn both cases, the assembler must be able to determine the size of each instruction on the initial passes in order to calculate the addresses of subsequent symbols. This means that if the size of an operation referring to an operand defined later depends on the type or distance of the operand, the assembler will make a pessimistic estimate when first encountering the operation, and if necessary, pad it with one or more\n\"[[NOP (code)|no-operation]]\" instructions in a later pass or the errata. In an assembler with [[peephole optimization]], addresses may be recalculated between passes to allow replacing pessimistic code with code tailored to the exact distance from the target.\n\nThe original reason for the use of one-pass assemblers was speed of assembly \u2013 often a second pass would require rewinding and rereading the program source on [[Magnetic tape data storage|tape]] or rereading a deck of [[Punch cards|cards]] or [[Punched tape|punched paper tape]]. Later computers with much larger memories (especially disc storage), had the space to perform all necessary processing without such re-reading. The advantage of the multi-pass assembler is that the absence of errata makes the [[Linker (computing)|linking process]] (or the [[Loader (computing)|program load]] if the assembler directly produces executable code) faster.<ref>{{Cite book|last=Beck|first=Leland L.|title=System Software: An Introduction to Systems Programming|publisher=Addison Wesley|year=1996|chapter=2}}</ref>\n\n'''Example:''' in the following code snippet, a one-pass assembler would be able to determine the address of the backward reference <var>BKWD</var> when assembling statement <var>S2</var>, but would not be able to determine the address of the forward reference <var>FWD</var> when assembling the branch statement <var>S1</var>; indeed, <var>FWD</var> may be undefined. A two-pass assembler would determine both addresses in pass 1, so they would be known when generating code in pass 2.\n {{var|S1}}   B    {{var|FWD}}\n   ...\n {{var|FWD}}   EQU *\n   ...\n {{var|BKWD}}  EQU *\n   ...\n {{var|S2}}    B   {{var|BKWD}}\n\n", "attributes": [{"name": "Anchor", "values": [{"name": "1", "value": "Two-pass assembler"}]}, {"name": "Cite book", "values": [{"name": "last", "value": "Beck"}, {"name": "first", "value": "Leland L."}, {"name": "title", "value": "System Software: An Introduction to Systems Programming"}, {"name": "publisher", "value": "Addison Wesley"}, {"name": "year", "value": "1996"}, {"name": "chapter", "value": "2"}]}, {"name": "var", "values": [{"name": "1", "value": "S1"}]}, {"name": "var", "values": [{"name": "1", "value": "FWD"}]}, {"name": "var", "values": [{"name": "1", "value": "FWD"}]}, {"name": "var", "values": [{"name": "1", "value": "BKWD"}]}, {"name": "var", "values": [{"name": "1", "value": "S2"}]}, {"name": "var", "values": [{"name": "1", "value": "BKWD"}]}], "id": 5}, {"title": "High-level assemblers", "paragraphs": "More sophisticated [[high-level assembler]]s provide language abstractions such as:\n* High-level procedure/function declarations and invocations\n* Advanced control structures (IF/THEN/ELSE, SWITCH)\n* High-level abstract data types, including structures/records, unions, classes, and sets\n* Sophisticated macro processing (although available on ordinary assemblers since the late 1950s for [[IBM 700/7000 series|IBM 700 series]] and since the 1960s for [[IBM/360]], amongst other machines)\n* [[Object-oriented programming]] features such as [[class (computer programming)|classes]], [[Object (computer science)|objects]], [[Abstraction (computer science)|abstraction]], [[type polymorphism|polymorphism]], and [[inheritance (object-oriented programming)|inheritance]]<ref>Hyde, Randall. \"Chapter 12 \u2013 Classes and Objects\". The Art of Assembly Language, 2nd Edition. No Starch Press. \u00a9 2010.</ref>\nSee [[#Language design|Language design]] below for more details.\n\n", "attributes": [], "id": 6}, {"title": "Assembly language", "paragraphs": "A program written in assembly language consists of a series of [[mnemonic]] processor instructions and meta-statements (known variously as directives, pseudo-instructions and pseudo-ops), comments and data. Assembly language instructions usually consist of an [[opcode]] mnemonic followed by a list of data, arguments or parameters.<ref name=\"intel-1999\">{{cite book |title=Intel Architecture Software Developer's Manual, Volume 2: Instruction Set Reference |year=1999 |publisher=Intel Corporation |url=http://download.intel.com/design/PentiumII/manuals/24319102.PDF |accessdate=18 November 2010}}</ref> These are translated by an [[Assembly language assembler|assembler]] into [[machine language]] instructions that can be loaded into memory and executed.\n\nFor example, the instruction below tells an [[x86]]/[[IA-32]] processor to move an [[Constant (programming)|immediate 8-bit value]] into a [[processor register|register]]. The binary code for this instruction is 10110 followed by a 3-bit identifier for which register to use. The identifier for the ''AL'' register is 000, so the following [[machine code]] loads the ''AL'' register with the data 01100001.<ref name=\"intel-1999-MOV\">{{cite book |title=Intel Architecture Software Developer's Manual, Volume 2: Instruction Set Reference |year=1999 |publisher=Intel Corporation |pages=442 and 35|url=http://download.intel.com/design/PentiumII/manuals/24319102.PDF|accessdate=18 November 2010}}</ref>\n 10110000 01100001\nThis binary computer code can be made more human-readable by expressing it in [[hexadecimal]] as follows.\n B0 61\nHere, <code>B0</code> means 'Move a copy of the following value into ''AL'', and <code>61</code> is a hexadecimal representation of the value 01100001, which is 97 in [[decimal]]. Assembly language for the 8086 family provides the [[mnemonic]] [[MOV (x86 instruction)|MOV]] (an abbreviation of ''move'') for instructions such as this, so the machine code above can be written as follows in assembly language, complete with an explanatory comment if required, after the semicolon. This is much easier to read and to remember.\n<syntaxhighlight lang=\"nasm\">MOV AL, 61h       ; Load AL with 97 decimal (61 hex)</syntaxhighlight>\n\nIn some assembly languages (including this one) the same mnemonic, such as MOV, may be used for a family of related instructions for loading, copying and moving data, whether these are immediate values, values in registers, or memory locations pointed to by values in registers or by immediate (a/k/a direct) addresses.  Other assemblers may use separate opcode mnemonics such as L for \"move memory to register\", ST for \"move register to memory\", LR for \"move register to register\", MVI for \"move immediate operand to memory\", etc.\n\nIf the same mnemonic is used for different instructions, that means that the mnemonic corresponds to several different binary instruction codes, excluding data (e.g. the <code>61h</code> in this example), depending on the operands that follow the mnemonic.  For example, for the x86/IA-32 CPUs, the Intel assembly language syntax <code>MOV AL, AH</code> represents an instruction that moves the contents of register ''AH'' into register ''AL''.  The<ref>Actually, this is one of two redundant forms of this instruction that operate identically.  The 8086 and several other CPUs from the late 1970s/early 1980s have redundancies in their instruction sets, because it was simpler for engineers to design these CPUs (to fit on silicon chips of limited sizes) with the redundant codes than to eliminate them.  Each assembler will typically generate only one of two or more redundant instruction encodings, but a ''disassembler'' will usually recognize any of them.</ref> hexadecimal form of this instruction is:\n 88 E0\nThe first byte, 88h, identifies a move between a byte-sized register and either another register or memory, and the second byte, E0h, is encoded (with three bit-fields) to specify that both operands are registers, the source is ''AH'', and the destination is ''AL''.\n\nIn a case like this where the same mnemonic can represent more than one binary instruction, the assembler determines which instruction to generate by examining the operands.  In the first example, the operand <code>61h</code> is a valid hexadecimal numeric constant and is not a valid register name, so only the <code>B0</code> instruction can be applicable.  In the second example, the operand <code>AH</code> is a valid register name and not a valid numeric constant (hexadecimal, decimal, octal, or binary), so only the <code>88</code> instruction can be applicable.\n\nAssembly languages are always designed so that this sort of unambiguousness is universally enforced by their syntax.  For example, in the Intel x86 assembly language, a hexadecimal constant must start with a numeral digit, so that the hexadecimal number 'A' (equal to decimal ten) would be written as <code>0Ah</code> or <code>0AH</code>, not <code>AH</code>, specifically so that it cannot appear to be the name of register ''AH''.  (The same rule also prevents ambiguity with the names of registers ''BH'', ''CH'', and ''DH'', as well as with any user-defined symbol that ends with the letter ''H'' and otherwise contains only characters that are hexadecimal digits, such as the word \"BEACH\".)\n\nReturning to the original example, while the x86 opcode 10110000 (<code>B0</code>) copies an 8-bit value into the ''AL'' register, 10110001 (<code>B1</code>) moves it into ''CL'' and 10110010 (<code>B2</code>) does so into ''DL''. Assembly language examples for these follow.<ref name=\"intel-1999-MOV\"/>\n<syntaxhighlight lang=\"nasm\">\nMOV AL, 1h        ; Load AL with immediate value 1\nMOV CL, 2h        ; Load CL with immediate value 2\nMOV DL, 3h        ; Load DL with immediate value 3\n</syntaxhighlight>\nThe syntax of MOV can also be more complex as the following examples show.<ref>{{cite web|last=Evans|first=David|title=x86 Assembly Guide|url=http://www.cs.virginia.edu/~evans/cs216/guides/x86.html|publisher=University of Virginia|accessdate=18 November 2010|year=2006}}</ref>\n<syntaxhighlight lang=\"nasm\">\nMOV EAX, [EBX]\t  ; Move the 4 bytes in memory at the address contained in EBX into EAX\nMOV [ESI+EAX], CL ; Move the contents of CL into the byte at address ESI+EAX\nMOV DS, DX        ; Move the contents of DX into segment register DS\n</syntaxhighlight>\n<!-- The MOV to/from segment register opcodes are included below, so an example involving a segment register should be included. -->\nIn each case, the MOV mnemonic is translated directly into one of the opcodes 88-8C, 8E, A0-A3, B0-BF, C6 or C7 by an assembler, and the programmer normally does not have to know or remember which.<ref name=\"intel-1999-MOV\"/>\n\nTransforming assembly language into machine code is the job of an assembler, and the reverse can at least partially be achieved by a [[disassembler]]. Unlike [[high-level language]]s, there is a [[one-to-one correspondence]] between many simple assembly statements and machine language instructions. However, in some cases, an assembler may provide ''pseudoinstructions'' (essentially macros) which expand into several machine language instructions to provide commonly needed functionality. For example, for a machine that lacks a \"branch if greater or equal\" instruction, an assembler may provide a pseudoinstruction that expands to the machine's \"set if less than\" and \"branch if zero (on the result of the set instruction)\". Most full-featured assemblers also provide a rich [[macro (computer science)|macro]] language (discussed below) which is used by vendors and programmers to generate more complex code and data sequences. Since the information about pseudoinstructions and macros defined in the assembler environment is not present in the object program, a disassembler cannot reconstruct the macro and pseudoinstruction invocations but can only disassemble the actual machine instructions that the assembler generated from those abstract assembly-language entities. Likewise, since comments in the assembly language source file are ignored by the assembler and have no effect on the object code it generates, a disassembler is always completely unable to recover source comments.\n\nEach [[computer architecture]] has its own machine language.  Computers differ in the number and type of operations they support, in the different sizes and numbers of registers, and in the representations of data in storage. While most general-purpose computers are able to carry out essentially the same functionality, the ways they do so differ; the corresponding assembly languages reflect these differences.\n\nMultiple sets of [[mnemonic]]s or assembly-language syntax may exist for a single instruction set, typically instantiated in different assembler programs. In these cases, the most popular one is usually that supplied by the CPU manufacturer and used in its documentation.\n\nTwo examples of CPUs that have two different sets of mnemonics are the Intel 8080 family and the Intel 8086/8088.  Because Intel claimed copyright on its assembly language mnemonics (on each page of their documentation published in the 1970s and early 1980s, at least), some companies that independently produced CPUs compatible with Intel instruction sets invented their own mnemonics.  The Zilog Z80 CPU, an enhancement of the Intel 8080A, supports all the 8080A instructions plus many more; Zilog invented an entirely new assembly language, not only for the new instructions but also for all of the 8080A instructions.  For example, where Intel uses the mnemonics ''MOV'', ''MVI'', ''LDA'', ''STA'', ''LXI'', ''LDAX'', ''STAX'', ''LHLD'', and ''SHLD'' for various data transfer instructions, the Z80 assembly language uses the mnemonic ''LD'' for all of them.  A similar case is the NEC V30 and V20 CPUs, enhanced copies of the Intel 8086 and 8088, respectively.  Like Zilog with the Z80, NEC invented new mnemonics for all of the 8086 and 8088 instructions, to avoid accusations of infringement of Intel's copyright.  (It is questionable whether such copyrights can be valid, and later CPU companies such as AMD<ref>Note: AMD manufactured second-source Intel 8086, 8088, and 80286 CPUs, and perhaps 8080A and/or 8085A CPUs, under license from Intel, but starting with the 80386, Intel refused to share their x86 CPU designs with anyone&mdash;AMD sued about this for breach of contract&mdash;and AMD designed, made, and sold 32-bit and 64-bit x86-family CPUs without Intel's help or endorsement.</ref> and Cyrix republished Intel's x86/IA-32 instruction mnemonics exactly with neither permission nor legal penalty.)  It is doubtful whether in practice many people who programmed the V20 and V30 actually wrote in NEC's assembly language rather than Intel's; since any two assembly languages for the same instruction set architecture are isomorphic (somewhat like English and Pig Latin), there is no requirement to use a manufacturer's own published assembly language with that manufacturer's products.\n\n", "attributes": [{"name": "cite book ", "values": [{"name": "title", "value": "Intel Architecture Software Developer's Manual, Volume 2: Instruction Set Reference"}, {"name": "year", "value": "1999"}, {"name": "publisher", "value": "Intel Corporation"}, {"name": "url", "value": "http://download.intel.com/design/PentiumII/manuals/24319102.PDF"}, {"name": "accessdate", "value": "18 November 2010"}]}, {"name": "cite book ", "values": [{"name": "title", "value": "Intel Architecture Software Developer's Manual, Volume 2: Instruction Set Reference"}, {"name": "year", "value": "1999"}, {"name": "publisher", "value": "Intel Corporation"}, {"name": "pages", "value": "442 and 35"}, {"name": "url", "value": "http://download.intel.com/design/PentiumII/manuals/24319102.PDF"}, {"name": "accessdate", "value": "18 November 2010"}]}, {"name": "cite web", "values": [{"name": "last", "value": "Evans"}, {"name": "first", "value": "David"}, {"name": "title", "value": "x86 Assembly Guide"}, {"name": "url", "value": "http://www.cs.virginia.edu/~evans/cs216/guides/x86.html"}, {"name": "publisher", "value": "University of Virginia"}, {"name": "accessdate", "value": "18 November 2010"}, {"name": "year", "value": "2006"}]}], "id": 7}, {"title": "Language design", "paragraphs": "\n===Basic elements===\nThere is a large degree of diversity in the way the authors of assemblers categorize statements and in the nomenclature that they use. In particular, some describe anything other than a machine mnemonic or extended mnemonic as a pseudo-operation (pseudo-op). A typical assembly language consists of 3 types of instruction statements that are used to define program operations:\n*[[Opcode]] mnemonics\n*Data definitions\n*Assembly directives\n\n====Opcode mnemonics and extended mnemonics====\nInstructions (statements) in assembly language are generally very simple, unlike those in [[high-level programming language|high-level languages]]. Generally, a mnemonic is a symbolic name for a single executable machine language instruction (an [[opcode]]), and there is at least one opcode mnemonic defined for each machine language instruction. Each instruction typically consists of an ''operation'' or ''opcode'' plus zero or more ''[[operand]]s''. Most instructions refer to a single value, or a pair of values.  Operands can be immediate (value coded in the instruction itself), registers specified in the instruction or implied, or the addresses of data located elsewhere in storage. This is determined by the underlying processor architecture: the assembler merely reflects how this architecture works. ''Extended mnemonics'' are often used to specify a combination of an opcode with a specific operand, e.g., the System/360 assemblers use {{code|B}} as an extended mnemonic for {{code|BC}} with a mask of 15 and {{code|NOP}} (\"NO OPeration\" \u2013 do nothing for one step) for {{code|BC}} with a mask of 0.\n\n''Extended mnemonics'' are often used to support specialized uses of instructions, often for purposes not obvious from the instruction name. For example, many CPU's do not have an explicit NOP instruction, but do have instructions that can be used for the purpose. In 8086 CPUs the instruction {{code|2=asm|xchg ax,ax}} is used for {{code|nop}}, with {{code|nop}} being a pseudo-opcode to encode the instruction {{code|2=asm|xchg ax,ax}}. Some disassemblers recognize this and will decode the {{code|2=asm|xchg ax,ax}} instruction as {{code|nop}}. Similarly, IBM assemblers for [[IBM System/360|System/360]] and [[IBM System/370|System/370]] use the extended mnemonics {{code|NOP}} and {{code|NOPR}} for {{code|BC}} and {{code|BCR}} with zero masks.  For the SPARC architecture, these are known as ''synthetic instructions''.<ref>{{cite web|url=http://www.sparc.com/standards/V8.pdf |publisher=SPARC, International |title=The SPARC Architecture Manual, Version 8 |year=1992 |url-status=dead |archiveurl=https://web.archive.org/web/20111210201410/http://www.sparc.com/standards/V8.pdf |archivedate=2011-12-10 }}</ref>\n\nSome assemblers also support simple built-in macro-instructions that generate two or more machine instructions. For instance, with some Z80 assemblers the instruction {{code|ld hl,bc}} is recognized to generate {{code|ld l,c}} followed by {{code|ld h,b}}.<ref>[http://www.z80.de/z80/z80code.htm Z80 Op Codes for ZINT]. Z80.de. Retrieved on 2013-07-21.</ref> These are sometimes known as ''pseudo-opcodes''.\n\nMnemonics are arbitrary symbols; in 1985 the [[IEEE]] published Standard 694 for a uniform set of mnemonics to be used by all assemblers. The standard has since been withdrawn.\n\n====Data directives====\nThere are instructions used to define data elements to hold data and variables.  They define the type of data, the length and the [[data structure alignment|alignment]] of data. These instructions can also define whether the data is available to outside programs (programs assembled separately) or only to the program in which the data section is defined. Some assemblers classify these as pseudo-ops.\n\n====Assembly directives====\n\nAssembly directives, also called pseudo-opcodes, pseudo-operations or pseudo-ops, are commands given to an assembler \"directing it to perform operations other than assembling instructions.\".<ref name=\"Salomon\"/> Directives affect how the assembler operates and \"may affect the object code, the symbol table, the listing file, and the values of internal assembler parameters.\"  Sometimes the term ''pseudo-opcode'' is reserved for directives that generate object code, such as those that generate data.<ref>{{cite web|last=Microsoft Corporation|title=MASM: Directives & Pseudo-Opcodes|url=http://flint.cs.yale.edu/cs422/doc/art-of-asm/pdf/CH08.PDF|accessdate=March 19, 2011}}</ref>\n\nThe names of pseudo-ops often start with a dot to distinguish them from machine instructions.  Pseudo-ops can make the assembly of the program dependent on parameters input by a programmer, so that one program can be assembled in different ways, perhaps for different applications. Or, a pseudo-op can be used to manipulate presentation of a program to make it easier to read and maintain. Another common use of pseudo-ops is to reserve storage areas for run-time data and optionally initialize their contents to known values.\n\nSymbolic assemblers let programmers associate arbitrary names (''[[label (programming language)|label]]s'' or ''symbols'') with memory locations and various constants. Usually, every constant and variable is given a name so instructions can reference those locations by name, thus promoting [[self-documenting code]]. In executable code, the name of each subroutine is associated with its entry point, so any calls to a subroutine can use its name. Inside subroutines, [[GOTO]] destinations are given labels. Some assemblers support ''local symbols'' which are often lexically distinct from normal symbols (e.g., the use of \"10$\" as a GOTO destination).\n\nSome assemblers, such as NASM, provide flexible symbol management, letting programmers manage different [[namespace]]s, automatically calculate offsets within [[data structure]]s, and assign labels that refer to literal values or the result of simple computations performed by the assembler. Labels can also be used to initialize constants and variables with relocatable addresses.\n\nAssembly languages, like most other computer languages, allow comments to be added to program [[source code]] that will be ignored during assembly. Judicious commenting is essential in assembly language programs, as the meaning and purpose of a sequence of binary machine instructions can be difficult to determine. The \"raw\" (uncommented) assembly language generated by compilers or disassemblers is quite difficult to read when changes must be made.\n\n===Macros===\nMany assemblers support ''predefined macros'', and others support ''programmer-defined'' (and repeatedly re-definable) macros involving sequences of text lines in which variables and constants are embedded. The macro definition is most commonly{{efn|In 7070 Autocoder, a macro definition is a 7070 macro generator program that the assembler calls; Autocoder provides special macros for macro generators to use.}} a mixture of assembler statements, e.g., directives, symbolic machine instructions, and templates for assembler statements. This sequence of text lines may include opcodes or directives. Once a macro has been defined its name may be used in place of a mnemonic. When the assembler processes such a statement, it replaces the statement with the text lines associated with that macro, then processes them as if they existed in the source code file (including, in some assemblers, expansion of any macros existing in the replacement text). Macros in this sense date to IBM [[autocoder]]s of the 1950s.<ref>{{cite book  |title=Users of 1401 Autocoder\n|url=http://bitsavers.trailing-edge.com/1401/progs/autocoder/mod.11.ps}}</ref>\n<ref>\"The following minor restriction or limitation is in effect with regard to the use of 1401 Autocoder when coding macro instructions ...\"</ref>\n\nIn assembly language, the term \"macro\" represents a more comprehensive concept than it does in some other contexts, such as in the [[C (programming language)|C programming language]], where its #define directive typically is used to create short single line macros. Assembler macro instructions, like macros in [[PL/I]] and some other languages, can be lengthy \"programs\" by themselves, executed by interpretation by the assembler during assembly.\n\nSince macros can have 'short' names but expand to several or indeed many lines of code, they can be used to make assembly language programs appear to be far shorter, requiring fewer lines of source code, as with higher level languages. They can also be used to add higher levels of structure to assembly programs, optionally introduce embedded debugging code via parameters and other similar features.\n\nMacro assemblers often allow macros to take [[parameter (computer science)|parameter]]s. Some assemblers include quite sophisticated macro languages, incorporating such high-level language elements as optional parameters, symbolic variables, conditionals, string manipulation, and arithmetic operations, all usable during the execution of a given macro, and allowing macros to save context or exchange information. Thus a macro might generate numerous assembly language instructions or data definitions, based on the macro arguments. This could be used to generate record-style data structures or \"unrolled\" loops, for example, or could generate entire algorithms based on complex parameters. For instance, a \"sort\" macro could accept the specification of a complex sort key and generate code crafted for that specific key, not needing the run-time tests that would be required  for a general procedure interpreting the specification. An organization using assembly language that has been heavily extended using such a macro suite can be considered to be working in a higher-level language, since such programmers are not working with a computer's lowest-level conceptual elements. Underlining this point, macros were used to implement an early [[virtual machine]] in [[SNOBOL4]] (1967), which was written in the SNOBOL Implementation Language (SIL), an assembly language for a virtual machine. The target machine would translate this to its native code using a [[macro assembler]].<ref>Griswold, Ralph E.  ''The Macro Implementation of SNOBOL4''.  San Francisco, CA: W. H. Freeman and Company, 1972 ({{ISBN|0-7167-0447-1}}), Chapter 1.</ref> This allowed a high degree of portability for the time.\n\nMacros were used to customize large scale software systems for specific customers in the mainframe era and were also used by customer personnel to satisfy their employers' needs by making specific versions of manufacturer operating systems. This was done, for example, by systems programmers working with [[IBM]]'s Conversational Monitor System / Virtual Machine ([[VM/CMS]]) and with IBM's \"real time transaction processing\" add-ons, Customer Information Control System [[CICS]], and [[Airline Control Program|ACP]]/[[Transaction Processing Facility|TPF]], the airline/financial system that began in the 1970s and still runs many large [[computer reservation system]]s (CRS) and credit card systems today.\n\nIt is also possible to use solely the macro processing abilities of an assembler to generate code written in completely different languages, for example, to generate a version of a program in [[COBOL]] using a pure macro assembler program containing lines of COBOL code inside assembly time operators instructing the assembler to generate arbitrary code. IBM [[OS/360]] uses macros to perform [[system generation]]. The user specifies options by coding a series of assembler macros.  Assembling these macros generates a [[job stream]] to build the system, including [[job control language]] and [[IBM mainframe utility programs|utility]] control statements.\n\nThis is because, as was realized in the 1960s, the concept of \"macro processing\" is independent of the concept of \"assembly\", the former being in modern terms more word processing, text processing, than generating object code. The concept of macro processing appeared, and appears, in the C programming language, which supports \"preprocessor instructions\" to set variables, and make conditional tests on their values. Note that unlike certain previous macro processors inside assemblers, the C preprocessor is not [[Turing completeness|Turing-complete]] because it lacks the ability to either loop or \"go to\", the latter allowing programs to loop.\n\nDespite the power of macro processing, it fell into disuse in many high level languages (major exceptions being [[C_(programming language)|C]], [[C++]] and [[PL/I]]) while remaining a perennial for assemblers.\n\nMacro parameter substitution is strictly by name: at macro processing time, the value of a parameter is textually substituted for its name. The most famous class of bugs resulting was the use of a parameter that itself was an expression and not a simple name when the macro writer expected a name. In the macro:\n\n foo: macro a\n load a*b\n\nthe intention was that the caller would provide the name of a variable, and the \"global\" variable or constant b would be used to multiply \"a\". If foo is called with the parameter <code>a-c</code>, the macro expansion of <code>load a-c*b</code> occurs.  To avoid any possible ambiguity, users of macro processors can parenthesize formal parameters inside macro definitions, or callers can parenthesize the input parameters.<ref>{{cite web\n   |url=http://msdn.microsoft.com/en-us/library/503x3e3s%28v=VS.90%29.aspx\n   |title=Macros (C/C++), MSDN Library for Visual Studio 2008\n   |publisher=Microsoft Corp.\n   |accessdate=2010-06-22\n}}</ref>\n\n===Support for structured programming===\nSome assemblers have incorporated [[structured programming]] elements to encode execution flow. The earliest example of this approach was in the [[Concept-14 macro set]], originally proposed by Dr. [[Harlan Mills]] (March 1970), and implemented by Marvin Kessler at IBM's Federal Systems Division, which extended the S/360 macro assembler with IF/ELSE/ENDIF and similar control flow blocks.<ref>{{cite web\n   |url=http://skycoast.us/pscott/software/mvs/concept14.html\n   |title=Concept 14 Macros\n   |publisher=MVS Software\n   |accessdate=May 25, 2009\n}}</ref> This was a way to reduce or eliminate the use of [[GOTO]] operations in assembly code, one of the main factors causing [[spaghetti code]] in assembly language. This approach was widely accepted in the early '80s (the latter days of large-scale assembly language use).\n\nA curious design was [[A-natural]], a \"stream-oriented\" assembler for 8080/[[Z80]] processors{{Citation needed|date=January 2009}} from [[Whitesmiths|Whitesmiths Ltd.]] (developers of the [[Unix]]-like [[Idris (operating system)|Idris]] operating system, and what was reported to be the first commercial [[C (programming language)|C]] [[compiler]]). The language was classified as an assembler, because it worked with raw machine elements such as [[opcodes]], [[processor register|registers]], and memory references; but it incorporated an expression syntax to indicate execution order. Parentheses and other special symbols, along with block-oriented structured programming constructs, controlled the sequence of the generated instructions. A-natural was built as the object language of a C compiler, rather than for hand-coding, but its logical syntax won some fans.\n\nThere has been little apparent demand for more sophisticated assemblers since the decline of large-scale assembly language development.<ref name=\"assembly-language?cat=technology\">{{cite web|url=http://www.answers.com/topic/assembly-language?cat=technology|title=assembly language: Definition and Much More from Answers.com|accessdate=2008-06-19|author=Answers.com}}</ref> In spite of that, they are still being developed and applied in cases where resource constraints or peculiarities in the target system's architecture prevent the effective use of higher-level languages.<ref>{{cite web |last=Provinciano |first=Brian |url=http://neshla.sourceforge.net/ |title=NESHLA: The High Level, Open Source, 6502 Assembler for the Nintendo Entertainment System}}</ref>\n\nAssemblers with a strong macro engine allow structured programming via macros, such as the switch macro provided with the Masm32 package (note this code is a complete program):\n\n<source lang=\"nasm\">\ninclude \\masm32\\include\\masm32rt.inc\t; use the Masm32 library\n\n.code\ndemomain:\n  REPEAT 20\n\tswitch rv(nrandom, 9)\t; generate a number between 0 and 8\n\tmov ecx, 7\n\tcase 0\n\t\tprint \"case 0\"\n\tcase ecx\t\t\t\t; in contrast to most other programming languages,\n\t\tprint \"case 7\"\t\t; the Masm32 switch allows \"variable cases\"\n\tcase 1 .. 3\n\t\t.if eax==1\n\t\t\tprint \"case 1\"\n\t\t.elseif eax==2\n\t\t\tprint \"case 2\"\n\t\t.else\n\t\t\tprint \"cases 1 to 3: other\"\n\t\t.endif\n\tcase 4, 6, 8\n\t\tprint \"cases 4, 6 or 8\"\n\tdefault\n\t\tmov ebx, 19\t\t     ; print 20 stars\n\t\t.Repeat\n\t\t\tprint \"*\"\n\t\t\tdec ebx\n\t\t.Until Sign?\t\t ; loop until the sign flag is set\n\tendsw\n\tprint chr$(13, 10)\n  ENDM\n  exit\nend demomain\n</source>\n\n", "attributes": [{"name": "code", "values": [{"name": "1", "value": "B"}]}, {"name": "code", "values": [{"name": "1", "value": "BC"}]}, {"name": "code", "values": [{"name": "1", "value": "NOP"}]}, {"name": "code", "values": [{"name": "1", "value": "BC"}]}, {"name": "code", "values": [{"name": "2", "value": "asm"}, {"name": "1", "value": "xchg ax,ax"}]}, {"name": "code", "values": [{"name": "1", "value": "nop"}]}, {"name": "code", "values": [{"name": "1", "value": "nop"}]}, {"name": "code", "values": [{"name": "2", "value": "asm"}, {"name": "1", "value": "xchg ax,ax"}]}, {"name": "code", "values": [{"name": "2", "value": "asm"}, {"name": "1", "value": "xchg ax,ax"}]}, {"name": "code", "values": [{"name": "1", "value": "nop"}]}, {"name": "code", "values": [{"name": "1", "value": "NOP"}]}, {"name": "code", "values": [{"name": "1", "value": "NOPR"}]}, {"name": "code", "values": [{"name": "1", "value": "BC"}]}, {"name": "code", "values": [{"name": "1", "value": "BCR"}]}, {"name": "cite web", "values": [{"name": "url", "value": "http://www.sparc.com/standards/V8.pdf"}, {"name": "publisher", "value": "SPARC, International"}, {"name": "title", "value": "The SPARC Architecture Manual, Version 8"}, {"name": "year", "value": "1992"}, {"name": "url-status", "value": "dead"}, {"name": "archiveurl", "value": "https://web.archive.org/web/20111210201410/http://www.sparc.com/standards/V8.pdf"}, {"name": "archivedate", "value": "2011-12-10"}]}, {"name": "code", "values": [{"name": "1", "value": "ld hl,bc"}]}, {"name": "code", "values": [{"name": "1", "value": "ld l,c"}]}, {"name": "code", "values": [{"name": "1", "value": "ld h,b"}]}, {"name": "cite web", "values": [{"name": "last", "value": "Microsoft Corporation"}, {"name": "title", "value": "MASM: Directives & Pseudo-Opcodes"}, {"name": "url", "value": "http://flint.cs.yale.edu/cs422/doc/art-of-asm/pdf/CH08.PDF"}, {"name": "accessdate", "value": "March 19, 2011"}]}, {"name": "efn", "values": [{"name": "1", "value": "In 7070 Autocoder, a macro definition is a 7070 macro generator program that the assembler calls; Autocoder provides special macros for macro generators to use."}]}, {"name": "cite book  ", "values": [{"name": "title", "value": "Users of 1401 Autocoder"}, {"name": "url", "value": "http://bitsavers.trailing-edge.com/1401/progs/autocoder/mod.11.ps"}]}, {"name": "ISBN", "values": [{"name": "1", "value": "0-7167-0447-1"}]}, {"name": "cite web\n   ", "values": [{"name": "url", "value": "http://msdn.microsoft.com/en-us/library/503x3e3s%28v=VS.90%29.aspx"}, {"name": "title", "value": "Macros (C/C++), MSDN Library for Visual Studio 2008"}, {"name": "publisher", "value": "Microsoft Corp."}, {"name": "accessdate", "value": "2010-06-22"}]}, {"name": "cite web\n   ", "values": [{"name": "url", "value": "http://skycoast.us/pscott/software/mvs/concept14.html"}, {"name": "title", "value": "Concept 14 Macros"}, {"name": "publisher", "value": "MVS Software"}, {"name": "accessdate", "value": "May 25, 2009"}]}, {"name": "Citation needed", "values": [{"name": "date", "value": "January 2009"}]}, {"name": "cite web", "values": [{"name": "url", "value": "http://www.answers.com/topic/assembly-language?cat=technology"}, {"name": "title", "value": "assembly language: Definition and Much More from Answers.com"}, {"name": "accessdate", "value": "2008-06-19"}, {"name": "author", "value": "Answers.com"}]}, {"name": "cite web ", "values": [{"name": "last", "value": "Provinciano"}, {"name": "first", "value": "Brian"}, {"name": "url", "value": "http://neshla.sourceforge.net/"}, {"name": "title", "value": "NESHLA: The High Level, Open Source, 6502 Assembler for the Nintendo Entertainment System"}]}], "id": 8}, {"title": "Basic elements", "paragraphs": "There is a large degree of diversity in the way the authors of assemblers categorize statements and in the nomenclature that they use. In particular, some describe anything other than a machine mnemonic or extended mnemonic as a pseudo-operation (pseudo-op). A typical assembly language consists of 3 types of instruction statements that are used to define program operations:\n*[[Opcode]] mnemonics\n*Data definitions\n*Assembly directives\n\n====Opcode mnemonics and extended mnemonics====\nInstructions (statements) in assembly language are generally very simple, unlike those in [[high-level programming language|high-level languages]]. Generally, a mnemonic is a symbolic name for a single executable machine language instruction (an [[opcode]]), and there is at least one opcode mnemonic defined for each machine language instruction. Each instruction typically consists of an ''operation'' or ''opcode'' plus zero or more ''[[operand]]s''. Most instructions refer to a single value, or a pair of values.  Operands can be immediate (value coded in the instruction itself), registers specified in the instruction or implied, or the addresses of data located elsewhere in storage. This is determined by the underlying processor architecture: the assembler merely reflects how this architecture works. ''Extended mnemonics'' are often used to specify a combination of an opcode with a specific operand, e.g., the System/360 assemblers use {{code|B}} as an extended mnemonic for {{code|BC}} with a mask of 15 and {{code|NOP}} (\"NO OPeration\" \u2013 do nothing for one step) for {{code|BC}} with a mask of 0.\n\n''Extended mnemonics'' are often used to support specialized uses of instructions, often for purposes not obvious from the instruction name. For example, many CPU's do not have an explicit NOP instruction, but do have instructions that can be used for the purpose. In 8086 CPUs the instruction {{code|2=asm|xchg ax,ax}} is used for {{code|nop}}, with {{code|nop}} being a pseudo-opcode to encode the instruction {{code|2=asm|xchg ax,ax}}. Some disassemblers recognize this and will decode the {{code|2=asm|xchg ax,ax}} instruction as {{code|nop}}. Similarly, IBM assemblers for [[IBM System/360|System/360]] and [[IBM System/370|System/370]] use the extended mnemonics {{code|NOP}} and {{code|NOPR}} for {{code|BC}} and {{code|BCR}} with zero masks.  For the SPARC architecture, these are known as ''synthetic instructions''.<ref>{{cite web|url=http://www.sparc.com/standards/V8.pdf |publisher=SPARC, International |title=The SPARC Architecture Manual, Version 8 |year=1992 |url-status=dead |archiveurl=https://web.archive.org/web/20111210201410/http://www.sparc.com/standards/V8.pdf |archivedate=2011-12-10 }}</ref>\n\nSome assemblers also support simple built-in macro-instructions that generate two or more machine instructions. For instance, with some Z80 assemblers the instruction {{code|ld hl,bc}} is recognized to generate {{code|ld l,c}} followed by {{code|ld h,b}}.<ref>[http://www.z80.de/z80/z80code.htm Z80 Op Codes for ZINT]. Z80.de. Retrieved on 2013-07-21.</ref> These are sometimes known as ''pseudo-opcodes''.\n\nMnemonics are arbitrary symbols; in 1985 the [[IEEE]] published Standard 694 for a uniform set of mnemonics to be used by all assemblers. The standard has since been withdrawn.\n\n====Data directives====\nThere are instructions used to define data elements to hold data and variables.  They define the type of data, the length and the [[data structure alignment|alignment]] of data. These instructions can also define whether the data is available to outside programs (programs assembled separately) or only to the program in which the data section is defined. Some assemblers classify these as pseudo-ops.\n\n====Assembly directives====\n\nAssembly directives, also called pseudo-opcodes, pseudo-operations or pseudo-ops, are commands given to an assembler \"directing it to perform operations other than assembling instructions.\".<ref name=\"Salomon\"/> Directives affect how the assembler operates and \"may affect the object code, the symbol table, the listing file, and the values of internal assembler parameters.\"  Sometimes the term ''pseudo-opcode'' is reserved for directives that generate object code, such as those that generate data.<ref>{{cite web|last=Microsoft Corporation|title=MASM: Directives & Pseudo-Opcodes|url=http://flint.cs.yale.edu/cs422/doc/art-of-asm/pdf/CH08.PDF|accessdate=March 19, 2011}}</ref>\n\nThe names of pseudo-ops often start with a dot to distinguish them from machine instructions.  Pseudo-ops can make the assembly of the program dependent on parameters input by a programmer, so that one program can be assembled in different ways, perhaps for different applications. Or, a pseudo-op can be used to manipulate presentation of a program to make it easier to read and maintain. Another common use of pseudo-ops is to reserve storage areas for run-time data and optionally initialize their contents to known values.\n\nSymbolic assemblers let programmers associate arbitrary names (''[[label (programming language)|label]]s'' or ''symbols'') with memory locations and various constants. Usually, every constant and variable is given a name so instructions can reference those locations by name, thus promoting [[self-documenting code]]. In executable code, the name of each subroutine is associated with its entry point, so any calls to a subroutine can use its name. Inside subroutines, [[GOTO]] destinations are given labels. Some assemblers support ''local symbols'' which are often lexically distinct from normal symbols (e.g., the use of \"10$\" as a GOTO destination).\n\nSome assemblers, such as NASM, provide flexible symbol management, letting programmers manage different [[namespace]]s, automatically calculate offsets within [[data structure]]s, and assign labels that refer to literal values or the result of simple computations performed by the assembler. Labels can also be used to initialize constants and variables with relocatable addresses.\n\nAssembly languages, like most other computer languages, allow comments to be added to program [[source code]] that will be ignored during assembly. Judicious commenting is essential in assembly language programs, as the meaning and purpose of a sequence of binary machine instructions can be difficult to determine. The \"raw\" (uncommented) assembly language generated by compilers or disassemblers is quite difficult to read when changes must be made.\n\n", "attributes": [{"name": "code", "values": [{"name": "1", "value": "B"}]}, {"name": "code", "values": [{"name": "1", "value": "BC"}]}, {"name": "code", "values": [{"name": "1", "value": "NOP"}]}, {"name": "code", "values": [{"name": "1", "value": "BC"}]}, {"name": "code", "values": [{"name": "2", "value": "asm"}, {"name": "1", "value": "xchg ax,ax"}]}, {"name": "code", "values": [{"name": "1", "value": "nop"}]}, {"name": "code", "values": [{"name": "1", "value": "nop"}]}, {"name": "code", "values": [{"name": "2", "value": "asm"}, {"name": "1", "value": "xchg ax,ax"}]}, {"name": "code", "values": [{"name": "2", "value": "asm"}, {"name": "1", "value": "xchg ax,ax"}]}, {"name": "code", "values": [{"name": "1", "value": "nop"}]}, {"name": "code", "values": [{"name": "1", "value": "NOP"}]}, {"name": "code", "values": [{"name": "1", "value": "NOPR"}]}, {"name": "code", "values": [{"name": "1", "value": "BC"}]}, {"name": "code", "values": [{"name": "1", "value": "BCR"}]}, {"name": "cite web", "values": [{"name": "url", "value": "http://www.sparc.com/standards/V8.pdf"}, {"name": "publisher", "value": "SPARC, International"}, {"name": "title", "value": "The SPARC Architecture Manual, Version 8"}, {"name": "year", "value": "1992"}, {"name": "url-status", "value": "dead"}, {"name": "archiveurl", "value": "https://web.archive.org/web/20111210201410/http://www.sparc.com/standards/V8.pdf"}, {"name": "archivedate", "value": "2011-12-10"}]}, {"name": "code", "values": [{"name": "1", "value": "ld hl,bc"}]}, {"name": "code", "values": [{"name": "1", "value": "ld l,c"}]}, {"name": "code", "values": [{"name": "1", "value": "ld h,b"}]}, {"name": "cite web", "values": [{"name": "last", "value": "Microsoft Corporation"}, {"name": "title", "value": "MASM: Directives & Pseudo-Opcodes"}, {"name": "url", "value": "http://flint.cs.yale.edu/cs422/doc/art-of-asm/pdf/CH08.PDF"}, {"name": "accessdate", "value": "March 19, 2011"}]}], "id": 9}, {"title": "Opcode mnemonics and extended mnemonics", "paragraphs": "Instructions (statements) in assembly language are generally very simple, unlike those in [[high-level programming language|high-level languages]]. Generally, a mnemonic is a symbolic name for a single executable machine language instruction (an [[opcode]]), and there is at least one opcode mnemonic defined for each machine language instruction. Each instruction typically consists of an ''operation'' or ''opcode'' plus zero or more ''[[operand]]s''. Most instructions refer to a single value, or a pair of values.  Operands can be immediate (value coded in the instruction itself), registers specified in the instruction or implied, or the addresses of data located elsewhere in storage. This is determined by the underlying processor architecture: the assembler merely reflects how this architecture works. ''Extended mnemonics'' are often used to specify a combination of an opcode with a specific operand, e.g., the System/360 assemblers use {{code|B}} as an extended mnemonic for {{code|BC}} with a mask of 15 and {{code|NOP}} (\"NO OPeration\" \u2013 do nothing for one step) for {{code|BC}} with a mask of 0.\n\n''Extended mnemonics'' are often used to support specialized uses of instructions, often for purposes not obvious from the instruction name. For example, many CPU's do not have an explicit NOP instruction, but do have instructions that can be used for the purpose. In 8086 CPUs the instruction {{code|2=asm|xchg ax,ax}} is used for {{code|nop}}, with {{code|nop}} being a pseudo-opcode to encode the instruction {{code|2=asm|xchg ax,ax}}. Some disassemblers recognize this and will decode the {{code|2=asm|xchg ax,ax}} instruction as {{code|nop}}. Similarly, IBM assemblers for [[IBM System/360|System/360]] and [[IBM System/370|System/370]] use the extended mnemonics {{code|NOP}} and {{code|NOPR}} for {{code|BC}} and {{code|BCR}} with zero masks.  For the SPARC architecture, these are known as ''synthetic instructions''.<ref>{{cite web|url=http://www.sparc.com/standards/V8.pdf |publisher=SPARC, International |title=The SPARC Architecture Manual, Version 8 |year=1992 |url-status=dead |archiveurl=https://web.archive.org/web/20111210201410/http://www.sparc.com/standards/V8.pdf |archivedate=2011-12-10 }}</ref>\n\nSome assemblers also support simple built-in macro-instructions that generate two or more machine instructions. For instance, with some Z80 assemblers the instruction {{code|ld hl,bc}} is recognized to generate {{code|ld l,c}} followed by {{code|ld h,b}}.<ref>[http://www.z80.de/z80/z80code.htm Z80 Op Codes for ZINT]. Z80.de. Retrieved on 2013-07-21.</ref> These are sometimes known as ''pseudo-opcodes''.\n\nMnemonics are arbitrary symbols; in 1985 the [[IEEE]] published Standard 694 for a uniform set of mnemonics to be used by all assemblers. The standard has since been withdrawn.\n\n", "attributes": [{"name": "code", "values": [{"name": "1", "value": "B"}]}, {"name": "code", "values": [{"name": "1", "value": "BC"}]}, {"name": "code", "values": [{"name": "1", "value": "NOP"}]}, {"name": "code", "values": [{"name": "1", "value": "BC"}]}, {"name": "code", "values": [{"name": "2", "value": "asm"}, {"name": "1", "value": "xchg ax,ax"}]}, {"name": "code", "values": [{"name": "1", "value": "nop"}]}, {"name": "code", "values": [{"name": "1", "value": "nop"}]}, {"name": "code", "values": [{"name": "2", "value": "asm"}, {"name": "1", "value": "xchg ax,ax"}]}, {"name": "code", "values": [{"name": "2", "value": "asm"}, {"name": "1", "value": "xchg ax,ax"}]}, {"name": "code", "values": [{"name": "1", "value": "nop"}]}, {"name": "code", "values": [{"name": "1", "value": "NOP"}]}, {"name": "code", "values": [{"name": "1", "value": "NOPR"}]}, {"name": "code", "values": [{"name": "1", "value": "BC"}]}, {"name": "code", "values": [{"name": "1", "value": "BCR"}]}, {"name": "cite web", "values": [{"name": "url", "value": "http://www.sparc.com/standards/V8.pdf"}, {"name": "publisher", "value": "SPARC, International"}, {"name": "title", "value": "The SPARC Architecture Manual, Version 8"}, {"name": "year", "value": "1992"}, {"name": "url-status", "value": "dead"}, {"name": "archiveurl", "value": "https://web.archive.org/web/20111210201410/http://www.sparc.com/standards/V8.pdf"}, {"name": "archivedate", "value": "2011-12-10"}]}, {"name": "code", "values": [{"name": "1", "value": "ld hl,bc"}]}, {"name": "code", "values": [{"name": "1", "value": "ld l,c"}]}, {"name": "code", "values": [{"name": "1", "value": "ld h,b"}]}], "id": 10}, {"title": "Data directives", "paragraphs": "There are instructions used to define data elements to hold data and variables.  They define the type of data, the length and the [[data structure alignment|alignment]] of data. These instructions can also define whether the data is available to outside programs (programs assembled separately) or only to the program in which the data section is defined. Some assemblers classify these as pseudo-ops.\n\n", "attributes": [], "id": 11}, {"title": "Assembly directives", "paragraphs": "\nAssembly directives, also called pseudo-opcodes, pseudo-operations or pseudo-ops, are commands given to an assembler \"directing it to perform operations other than assembling instructions.\".<ref name=\"Salomon\"/> Directives affect how the assembler operates and \"may affect the object code, the symbol table, the listing file, and the values of internal assembler parameters.\"  Sometimes the term ''pseudo-opcode'' is reserved for directives that generate object code, such as those that generate data.<ref>{{cite web|last=Microsoft Corporation|title=MASM: Directives & Pseudo-Opcodes|url=http://flint.cs.yale.edu/cs422/doc/art-of-asm/pdf/CH08.PDF|accessdate=March 19, 2011}}</ref>\n\nThe names of pseudo-ops often start with a dot to distinguish them from machine instructions.  Pseudo-ops can make the assembly of the program dependent on parameters input by a programmer, so that one program can be assembled in different ways, perhaps for different applications. Or, a pseudo-op can be used to manipulate presentation of a program to make it easier to read and maintain. Another common use of pseudo-ops is to reserve storage areas for run-time data and optionally initialize their contents to known values.\n\nSymbolic assemblers let programmers associate arbitrary names (''[[label (programming language)|label]]s'' or ''symbols'') with memory locations and various constants. Usually, every constant and variable is given a name so instructions can reference those locations by name, thus promoting [[self-documenting code]]. In executable code, the name of each subroutine is associated with its entry point, so any calls to a subroutine can use its name. Inside subroutines, [[GOTO]] destinations are given labels. Some assemblers support ''local symbols'' which are often lexically distinct from normal symbols (e.g., the use of \"10$\" as a GOTO destination).\n\nSome assemblers, such as NASM, provide flexible symbol management, letting programmers manage different [[namespace]]s, automatically calculate offsets within [[data structure]]s, and assign labels that refer to literal values or the result of simple computations performed by the assembler. Labels can also be used to initialize constants and variables with relocatable addresses.\n\nAssembly languages, like most other computer languages, allow comments to be added to program [[source code]] that will be ignored during assembly. Judicious commenting is essential in assembly language programs, as the meaning and purpose of a sequence of binary machine instructions can be difficult to determine. The \"raw\" (uncommented) assembly language generated by compilers or disassemblers is quite difficult to read when changes must be made.\n\n", "attributes": [{"name": "cite web", "values": [{"name": "last", "value": "Microsoft Corporation"}, {"name": "title", "value": "MASM: Directives & Pseudo-Opcodes"}, {"name": "url", "value": "http://flint.cs.yale.edu/cs422/doc/art-of-asm/pdf/CH08.PDF"}, {"name": "accessdate", "value": "March 19, 2011"}]}], "id": 12}, {"title": "Macros", "paragraphs": "Many assemblers support ''predefined macros'', and others support ''programmer-defined'' (and repeatedly re-definable) macros involving sequences of text lines in which variables and constants are embedded. The macro definition is most commonly{{efn|In 7070 Autocoder, a macro definition is a 7070 macro generator program that the assembler calls; Autocoder provides special macros for macro generators to use.}} a mixture of assembler statements, e.g., directives, symbolic machine instructions, and templates for assembler statements. This sequence of text lines may include opcodes or directives. Once a macro has been defined its name may be used in place of a mnemonic. When the assembler processes such a statement, it replaces the statement with the text lines associated with that macro, then processes them as if they existed in the source code file (including, in some assemblers, expansion of any macros existing in the replacement text). Macros in this sense date to IBM [[autocoder]]s of the 1950s.<ref>{{cite book  |title=Users of 1401 Autocoder\n|url=http://bitsavers.trailing-edge.com/1401/progs/autocoder/mod.11.ps}}</ref>\n<ref>\"The following minor restriction or limitation is in effect with regard to the use of 1401 Autocoder when coding macro instructions ...\"</ref>\n\nIn assembly language, the term \"macro\" represents a more comprehensive concept than it does in some other contexts, such as in the [[C (programming language)|C programming language]], where its #define directive typically is used to create short single line macros. Assembler macro instructions, like macros in [[PL/I]] and some other languages, can be lengthy \"programs\" by themselves, executed by interpretation by the assembler during assembly.\n\nSince macros can have 'short' names but expand to several or indeed many lines of code, they can be used to make assembly language programs appear to be far shorter, requiring fewer lines of source code, as with higher level languages. They can also be used to add higher levels of structure to assembly programs, optionally introduce embedded debugging code via parameters and other similar features.\n\nMacro assemblers often allow macros to take [[parameter (computer science)|parameter]]s. Some assemblers include quite sophisticated macro languages, incorporating such high-level language elements as optional parameters, symbolic variables, conditionals, string manipulation, and arithmetic operations, all usable during the execution of a given macro, and allowing macros to save context or exchange information. Thus a macro might generate numerous assembly language instructions or data definitions, based on the macro arguments. This could be used to generate record-style data structures or \"unrolled\" loops, for example, or could generate entire algorithms based on complex parameters. For instance, a \"sort\" macro could accept the specification of a complex sort key and generate code crafted for that specific key, not needing the run-time tests that would be required  for a general procedure interpreting the specification. An organization using assembly language that has been heavily extended using such a macro suite can be considered to be working in a higher-level language, since such programmers are not working with a computer's lowest-level conceptual elements. Underlining this point, macros were used to implement an early [[virtual machine]] in [[SNOBOL4]] (1967), which was written in the SNOBOL Implementation Language (SIL), an assembly language for a virtual machine. The target machine would translate this to its native code using a [[macro assembler]].<ref>Griswold, Ralph E.  ''The Macro Implementation of SNOBOL4''.  San Francisco, CA: W. H. Freeman and Company, 1972 ({{ISBN|0-7167-0447-1}}), Chapter 1.</ref> This allowed a high degree of portability for the time.\n\nMacros were used to customize large scale software systems for specific customers in the mainframe era and were also used by customer personnel to satisfy their employers' needs by making specific versions of manufacturer operating systems. This was done, for example, by systems programmers working with [[IBM]]'s Conversational Monitor System / Virtual Machine ([[VM/CMS]]) and with IBM's \"real time transaction processing\" add-ons, Customer Information Control System [[CICS]], and [[Airline Control Program|ACP]]/[[Transaction Processing Facility|TPF]], the airline/financial system that began in the 1970s and still runs many large [[computer reservation system]]s (CRS) and credit card systems today.\n\nIt is also possible to use solely the macro processing abilities of an assembler to generate code written in completely different languages, for example, to generate a version of a program in [[COBOL]] using a pure macro assembler program containing lines of COBOL code inside assembly time operators instructing the assembler to generate arbitrary code. IBM [[OS/360]] uses macros to perform [[system generation]]. The user specifies options by coding a series of assembler macros.  Assembling these macros generates a [[job stream]] to build the system, including [[job control language]] and [[IBM mainframe utility programs|utility]] control statements.\n\nThis is because, as was realized in the 1960s, the concept of \"macro processing\" is independent of the concept of \"assembly\", the former being in modern terms more word processing, text processing, than generating object code. The concept of macro processing appeared, and appears, in the C programming language, which supports \"preprocessor instructions\" to set variables, and make conditional tests on their values. Note that unlike certain previous macro processors inside assemblers, the C preprocessor is not [[Turing completeness|Turing-complete]] because it lacks the ability to either loop or \"go to\", the latter allowing programs to loop.\n\nDespite the power of macro processing, it fell into disuse in many high level languages (major exceptions being [[C_(programming language)|C]], [[C++]] and [[PL/I]]) while remaining a perennial for assemblers.\n\nMacro parameter substitution is strictly by name: at macro processing time, the value of a parameter is textually substituted for its name. The most famous class of bugs resulting was the use of a parameter that itself was an expression and not a simple name when the macro writer expected a name. In the macro:\n\n foo: macro a\n load a*b\n\nthe intention was that the caller would provide the name of a variable, and the \"global\" variable or constant b would be used to multiply \"a\". If foo is called with the parameter <code>a-c</code>, the macro expansion of <code>load a-c*b</code> occurs.  To avoid any possible ambiguity, users of macro processors can parenthesize formal parameters inside macro definitions, or callers can parenthesize the input parameters.<ref>{{cite web\n   |url=http://msdn.microsoft.com/en-us/library/503x3e3s%28v=VS.90%29.aspx\n   |title=Macros (C/C++), MSDN Library for Visual Studio 2008\n   |publisher=Microsoft Corp.\n   |accessdate=2010-06-22\n}}</ref>\n\n", "attributes": [{"name": "efn", "values": [{"name": "1", "value": "In 7070 Autocoder, a macro definition is a 7070 macro generator program that the assembler calls; Autocoder provides special macros for macro generators to use."}]}, {"name": "cite book  ", "values": [{"name": "title", "value": "Users of 1401 Autocoder"}, {"name": "url", "value": "http://bitsavers.trailing-edge.com/1401/progs/autocoder/mod.11.ps"}]}, {"name": "ISBN", "values": [{"name": "1", "value": "0-7167-0447-1"}]}, {"name": "cite web\n   ", "values": [{"name": "url", "value": "http://msdn.microsoft.com/en-us/library/503x3e3s%28v=VS.90%29.aspx"}, {"name": "title", "value": "Macros (C/C++), MSDN Library for Visual Studio 2008"}, {"name": "publisher", "value": "Microsoft Corp."}, {"name": "accessdate", "value": "2010-06-22"}]}], "id": 13}, {"title": "Support for structured programming", "paragraphs": "Some assemblers have incorporated [[structured programming]] elements to encode execution flow. The earliest example of this approach was in the [[Concept-14 macro set]], originally proposed by Dr. [[Harlan Mills]] (March 1970), and implemented by Marvin Kessler at IBM's Federal Systems Division, which extended the S/360 macro assembler with IF/ELSE/ENDIF and similar control flow blocks.<ref>{{cite web\n   |url=http://skycoast.us/pscott/software/mvs/concept14.html\n   |title=Concept 14 Macros\n   |publisher=MVS Software\n   |accessdate=May 25, 2009\n}}</ref> This was a way to reduce or eliminate the use of [[GOTO]] operations in assembly code, one of the main factors causing [[spaghetti code]] in assembly language. This approach was widely accepted in the early '80s (the latter days of large-scale assembly language use).\n\nA curious design was [[A-natural]], a \"stream-oriented\" assembler for 8080/[[Z80]] processors{{Citation needed|date=January 2009}} from [[Whitesmiths|Whitesmiths Ltd.]] (developers of the [[Unix]]-like [[Idris (operating system)|Idris]] operating system, and what was reported to be the first commercial [[C (programming language)|C]] [[compiler]]). The language was classified as an assembler, because it worked with raw machine elements such as [[opcodes]], [[processor register|registers]], and memory references; but it incorporated an expression syntax to indicate execution order. Parentheses and other special symbols, along with block-oriented structured programming constructs, controlled the sequence of the generated instructions. A-natural was built as the object language of a C compiler, rather than for hand-coding, but its logical syntax won some fans.\n\nThere has been little apparent demand for more sophisticated assemblers since the decline of large-scale assembly language development.<ref name=\"assembly-language?cat=technology\">{{cite web|url=http://www.answers.com/topic/assembly-language?cat=technology|title=assembly language: Definition and Much More from Answers.com|accessdate=2008-06-19|author=Answers.com}}</ref> In spite of that, they are still being developed and applied in cases where resource constraints or peculiarities in the target system's architecture prevent the effective use of higher-level languages.<ref>{{cite web |last=Provinciano |first=Brian |url=http://neshla.sourceforge.net/ |title=NESHLA: The High Level, Open Source, 6502 Assembler for the Nintendo Entertainment System}}</ref>\n\nAssemblers with a strong macro engine allow structured programming via macros, such as the switch macro provided with the Masm32 package (note this code is a complete program):\n\n<source lang=\"nasm\">\ninclude \\masm32\\include\\masm32rt.inc\t; use the Masm32 library\n\n.code\ndemomain:\n  REPEAT 20\n\tswitch rv(nrandom, 9)\t; generate a number between 0 and 8\n\tmov ecx, 7\n\tcase 0\n\t\tprint \"case 0\"\n\tcase ecx\t\t\t\t; in contrast to most other programming languages,\n\t\tprint \"case 7\"\t\t; the Masm32 switch allows \"variable cases\"\n\tcase 1 .. 3\n\t\t.if eax==1\n\t\t\tprint \"case 1\"\n\t\t.elseif eax==2\n\t\t\tprint \"case 2\"\n\t\t.else\n\t\t\tprint \"cases 1 to 3: other\"\n\t\t.endif\n\tcase 4, 6, 8\n\t\tprint \"cases 4, 6 or 8\"\n\tdefault\n\t\tmov ebx, 19\t\t     ; print 20 stars\n\t\t.Repeat\n\t\t\tprint \"*\"\n\t\t\tdec ebx\n\t\t.Until Sign?\t\t ; loop until the sign flag is set\n\tendsw\n\tprint chr$(13, 10)\n  ENDM\n  exit\nend demomain\n</source>\n\n", "attributes": [{"name": "cite web\n   ", "values": [{"name": "url", "value": "http://skycoast.us/pscott/software/mvs/concept14.html"}, {"name": "title", "value": "Concept 14 Macros"}, {"name": "publisher", "value": "MVS Software"}, {"name": "accessdate", "value": "May 25, 2009"}]}, {"name": "Citation needed", "values": [{"name": "date", "value": "January 2009"}]}, {"name": "cite web", "values": [{"name": "url", "value": "http://www.answers.com/topic/assembly-language?cat=technology"}, {"name": "title", "value": "assembly language: Definition and Much More from Answers.com"}, {"name": "accessdate", "value": "2008-06-19"}, {"name": "author", "value": "Answers.com"}]}, {"name": "cite web ", "values": [{"name": "last", "value": "Provinciano"}, {"name": "first", "value": "Brian"}, {"name": "url", "value": "http://neshla.sourceforge.net/"}, {"name": "title", "value": "NESHLA: The High Level, Open Source, 6502 Assembler for the Nintendo Entertainment System"}]}], "id": 14}, {"title": "Use of assembly language", "paragraphs": "\n===Historical perspective===\nAssembly languages were not available at the time when the [[stored-program computer]] was introduced. [[Kathleen Booth]] \"is credited with inventing\nassembly language\"<ref name=ClarityBooth>{{cite web\n   |url=https://hackaday.com/2018/08/21/kathleen-booth-assembling-early-computers-while-inventing-assembly\n   |title=Kathleen Booth: Assembling Early Computers While Inventing Assembly\n   |accessdate=February 10, 2019}}</ref><ref name=Booth1947.pdf>{{cite journal\n   |author1=Andrew D. Booth  |author2=Kathleen H. V. Britten\n   |journal=Birkbeck College, London |date=September 1947\n   |url=http://mt-archive.info/Booth-1947.pdf\n   |accessdate=10 February 2019\n   |title=General considerations in the design of an all purpose electronic digital computer (Coding for the ARC, 2nd ed)\n  |quote=The non-original ideas, contained in the following text, have been derived from a number of sources, ... It is felt, however, that acknowledgement should be made to Prof. John von Neumann and to Dr. Herman Goldstein for many fruitful discussions ...}}</ref><ref>see TALK page for details</ref> based on theoretical work she began in 1947, while working on the [[APEXC|ARC2]] at [[Birkbeck, University of London]] following consultation by [[Andrew Donald Booth|Andrew Booth]] (later her husband) with mathematician [[John von Neumann]] and physicist [[Herman Goldstine]] at the [[Institute for Advanced Study]].<ref name=Booth1947.pdf/><ref name=\"birkbeck\">{{cite journal |last1=Campbell-Kelly|first1=Martin|title=The Development of Computer Programming in Britain (1945 to 1955)\n   |journal=IEEE Annals of the History of Computing |date=April 1982 |volume=4  \n   |issue=2 |pages=121\u2013139 |doi=10.1109/MAHC.1982.10016}}</ref> \n\nIn late 1948, the [[Electronic Delay Storage Automatic Calculator]] (EDSAC) had an assembler (named \"initial orders\") integrated into its [[Booting|bootstrap]] program. It used one-letter mnemonics developed by [[David Wheeler (computer scientist)|David Wheeler]], who is credited by the IEEE Computer Society as the creator of the first \"assembler.\"<ref>{{cite book | last1 = Salomon | title = Assemblers and Loaders | url = http://www.davidsalomon.name/assem.advertis/asl.pdf | accessdate = 2012-01-17 | page = 7 }}</ref><ref>{{cite journal|first=Martin|last=Campbell-Kelly|title=Programming the EDSAC|journal=IEEE Annals of the History of Computing|year=1980|volume=2|number=1|pages=7\u201336|doi=10.1109/MAHC.1980.10009}}</ref> <ref>https://www.computer.org/web/awards/pioneer-david-wheeler 1985 Computer Pioneer Award 'For assembly language programming' David Wheeler</ref> Reports on the EDSAC introduced the term \"assembly\" for the process of combining fields into an instruction word.<ref>{{cite journal|first=Maurice V.|last=Wilkes|authorlink=Maurice Wilkes|title=The EDSAC \u2013 an Electronic Calculating Machine|journal=Journal of Scientific Instruments|year=1949|volume=26|issue=12|pages=385\u2013391|doi=10.1088/0950-7671/26/12/301}}</ref> SOAP (Symbolic Optimal Assembly Program) was an assembly language for the [[IBM 650]] computer written by Stan Poley in 1955.<ref>{{cite web |url=http://www.columbia.edu/cu/computinghistory/650.html |title=The IBM 650 Magnetic Drum Calculator |accessdate=2012-01-17}}</ref>\n\nAssembly languages eliminate much of the error-prone, tedious, and time-consuming [[first-generation language|first-generation]] programming needed with the earliest computers, freeing programmers from tedium such as remembering numeric codes and calculating addresses. They were once widely used for all sorts of programming. However, by the 1980s (1990s on [[microcomputer]]s), their use had largely been supplanted by higher-level languages, in the search for improved [[programming productivity]]. Today assembly language is still used for direct hardware manipulation, access to specialized processor instructions, or to address critical performance issues. Typical uses are [[device driver]]s, low-level [[embedded system]]s, and [[real-time computing|real-time]] systems.\n\nHistorically, numerous programs have been written entirely in assembly language. The [[Burroughs MCP]] (1961) was the first computer for which an operating system was not developed entirely in assembly language; it was written in [[Executive Systems Problem Oriented Language]] (ESPOL), an Algol dialect. Many commercial applications were written in assembly language as well, including a large amount of the [[IBM mainframe]] software written by large corporations. [[COBOL]], [[FORTRAN]] and some [[PL/I]] eventually displaced much of this work, although a number of large organizations retained assembly-language application infrastructures well into the 1990s.\n\nMost early microcomputers relied on hand-coded assembly language, including most operating systems and large applications. This was because these systems had severe resource constraints, imposed idiosyncratic memory and display architectures, and provided limited, buggy system services. Perhaps more important was the lack of first-class high-level language compilers suitable for microcomputer use. A psychological factor may have also played a role: the first generation of microcomputer programmers retained a hobbyist, \"wires and pliers\" attitude.\n\nIn a more commercial context, the biggest reasons for using assembly language were minimal bloat (size), minimal overhead, greater speed, and reliability.\n\nTypical examples of large assembly language programs from this time are IBM PC [[DOS]] operating systems, the [[Turbo Pascal]] compiler and early applications such as the [[spreadsheet]] program [[Lotus 1-2-3]]. Assembly language was used to get the best performance out of the [[Sega Saturn]], a console that was notoriously challenging to develop and program games for.<ref>{{Cite web |url=http://www.eidolons-inn.net/tiki-index.php?page=SegaBase+Saturn |title=Eidolon's Inn: SegaBase Saturn<!-- Bot generated title --> |access-date=2008-07-25 |archive-url=https://web.archive.org/web/20080713074116/http://www.eidolons-inn.net/tiki-index.php?page=SegaBase+Saturn |archive-date=2008-07-13 |url-status=dead }}</ref> The 1993 arcade game ''[[NBA Jam (1993 video game)|NBA Jam]]'' is another example.\n\nAssembly language has long been the primary development language for many popular home computers of the 1980s and 1990s (such as the [[MSX]],  [[Sinclair Research|Sinclair]] [[ZX Spectrum]], [[Commodore 64]], [[Commodore Amiga]], and [[Atari ST]]). This was in large part because [[Interpreted language|interpreted]] BASIC dialects on these systems offered insufficient execution speed, as well as insufficient facilities to take full advantage of the available hardware on these systems. Some systems even have an [[integrated development environment]] (IDE) with highly advanced debugging and macro facilities. Some compilers available for the [[Radio Shack]] [[TRS-80]] and its successors had the capability to combine inline assembly source with high-level program statements. Upon compilation a built-in assembler produced inline machine code.\n\n===Current usage===\nThere have always<ref>{{cite book\n   |title=Windows Assembly Language and Systems Programming: 16- and 32-Bit\n   |url=https://books.google.com/books?isbn=1482275724  |isbn=978-1482275728  \n   |author=Barry Kauler  |date=1997\n   |quote=Always the debate rages about the applicability of assembly language in our modern programming world.}}</ref> been debates over the usefulness and performance of assembly language relative to high-level languages. \n\nAlthough assembly language has specific niche uses where it is important (see below), there are other tools for optimization.<ref>{{cite web\n   |url=http://icps.u-strasbg.fr/~bastoul/local_copies/hsieh.html\n   |title=Programming Optimization\n   |author=Paul Hsieh  \n   |quote=... design changes tend to affect performance more than ... one should not skip straight to assembly language until ...}}</ref>\n\n{{As of|2017|07}}, the [[TIOBE index]] of programming language popularity ranks assembly language at 11, ahead of [[Visual Basic]], for example.<ref name=\"tiobe\">{{cite news|url=http://www.tiobe.com/tiobe_index |title=TIOBE Index|publisher=TIOBE Software}}</ref> Assembler can be used to optimize for speed or optimize for size. In the case of speed optimization, modern [[optimizing compiler]]s are claimed<ref>{{cite web|last=Rusling|first=David A.|title=The Linux Kernel|url=http://tldp.org/LDP/tlk/basics/sw.html|accessdate=Mar 11, 2012}}</ref>  to render high-level languages into code that can run as fast as hand-written assembly, despite the counter-examples that can be found.<ref name=\"goto\">{{cite news|url=https://www.nytimes.com/2005/11/28/technology/28super.html?_r=1 |title=Writing the Fastest Code, by Hand, for Fun: A Human Computer Keeps Speeding Up Chips |publisher=New York Times, John Markoff |date=2005-11-28 |accessdate=2010-03-04}}</ref><ref name=\"bit-fild\">{{cite web |url=http://hardwarebug.org/2010/01/30/bit-field-badness/ |title=Bit-field-badness |publisher=hardwarebug.org |date=2010-01-30 |accessdate=2010-03-04 |archiveurl=https://web.archive.org/web/20100205120952/http://hardwarebug.org/2010/01/30/bit-field-badness/ |archivedate=2010-02-05 |url-status=dead }}</ref><ref name=\"gcc-mess\">{{cite web |url=http://hardwarebug.org/2009/05/13/gcc-makes-a-mess/ |title=GCC makes a mess |publisher=HardwareBug.org |date=2009-05-13 |accessdate=2010-03-04 |archiveurl=https://web.archive.org/web/20100316212040/http://hardwarebug.org/2009/05/13/gcc-makes-a-mess/ |archivedate=2010-03-16 |url-status=dead }}</ref> The complexity of modern processors and memory sub-systems makes effective optimization increasingly difficult for compilers, as well as for assembly programmers.<ref name=\"GreatDebate1\">{{cite web|url=http://webster.cs.ucr.edu/Page_TechDocs/GreatDebate/debate1.html|title=The Great Debate|accessdate=2008-07-03|author=Randall Hyde|archiveurl=https://web.archive.org/web/20080616110102/http://webster.cs.ucr.edu/Page_TechDocs/GreatDebate/debate1.html|archivedate=2008-06-16|url-status=dead}}</ref><ref name=\"compiler-fails1\">{{cite web |url=http://hardwarebug.org/2008/11/28/codesourcery-fails-again/ |title=Code sourcery fails again |publisher=hardwarebug.org |date=2010-01-30 |accessdate=2010-03-04 |archiveurl=https://web.archive.org/web/20100402221204/http://hardwarebug.org/2008/11/28/codesourcery-fails-again/ |archivedate=2010-04-02 |url-status=dead }}</ref> Moreover, increasing processor performance has meant that most CPUs sit idle most of the time,<ref>{{cite web|last=Click|first=Cliff|title=A Crash Course in Modern Hardware|url=http://www.infoq.com/presentations/click-crash-course-modern-hardware|accessdate=May 1, 2014}}</ref> with delays caused by predictable bottlenecks such as cache misses, [[I/O]] operations and [[paging]]. This has made raw code execution speed a non-issue for many programmers.\n\nThere are some situations in which developers might choose to use assembly language:\n* Writing code for systems with older processors that have limited high-level language options such as the [[Atari 2600]], [[Commodore 64]], and [[graphing calculators]].<ref>{{cite web|url=http://tifreakware.net/tutorials/89/a/calc/fargoii.htm|title=68K Programming in Fargo II|accessdate=2008-07-03| archiveurl= https://web.archive.org/web/20080702181616/http://tifreakware.net/tutorials/89/a/calc/fargoii.htm| archivedate= 2 July 2008 | url-status= live}}</ref>\n* Code that must interact directly with the hardware, for example in [[device driver]]s and [[interrupt handler]]s.\n* In an embedded processor or DSP, high-repetition interrupts require the shortest number of cycles per interrupt, such as an interrupt that occurs 1000 or 10000 times a second.\n* Programs that need to use processor-specific instructions not implemented in a compiler. A common example is the [[circular shift|bitwise rotation]] instruction at the core of many encryption algorithms, as well as querying the parity of a byte or the 4-bit carry of an addition.\n* A stand-alone executable of compact size is required that must execute without recourse to the [[Run-time system|run-time]] components or [[library (computing)|libraries]] associated with a high-level language. Examples have included firmware for telephones, automobile fuel and ignition systems, air-conditioning control systems, security systems, and sensors.\n* Programs with performance-sensitive inner loops, where assembly language provides optimization opportunities that are difficult to achieve in a high-level language. For example, [[linear algebra]] with [[Basic Linear Algebra Subprograms|BLAS]]<ref name=\"goto\"/><ref name=\"bench\">{{cite web|url=http://eigen.tuxfamily.org/index.php?title=Benchmark-August2008 |title=BLAS Benchmark-August2008 |publisher=eigen.tuxfamily.org |date=2008-08-01 |accessdate=2010-03-04}}</ref> or [[DCT (math)|discrete cosine transformation]] (e.g. [[SIMD]] assembly version from [[x264]]<ref>{{cite web |url=http://git.videolan.org/?p=x264.git;a=tree;f=common/x86;hb=HEAD |title=x264.git/common/x86/dct-32.asm |publisher=git.videolan.org |date=2010-09-29 |accessdate=2010-09-29 |archive-url=https://web.archive.org/web/20120304083653/http://git.videolan.org/?p=x264.git%3Ba%3Dtree%3Bf%3Dcommon%2Fx86%3Bhb%3DHEAD |archive-date=2012-03-04 |url-status=dead }}</ref>).\n* Programs that create vectorized functions for programs in higher-level languages such as C.  In the higher-level language this is sometimes aided by compiler [[intrinsic function]]s which map directly to SIMD mnemonics, but nevertheless result in a one-to-one assembly conversion specific for the given vector processor.\n* [[real-time computing|Real-time]] programs such as simulations, flight navigation systems, and medical equipment. For example, in a [[fly-by-wire]] system, telemetry must be interpreted and acted upon within strict time constraints. Such systems must eliminate sources of unpredictable delays, which may be created by (some) interpreted languages, automatic [[garbage collection (computer science)|garbage collection]], paging operations, or [[preemptive multitasking]]. However, some higher-level languages incorporate run-time components and operating system interfaces that can introduce such delays. Choosing assembly or [[lower level language]]s for such systems gives programmers greater visibility and control over processing details.\n* Cryptographic algorithms that must always take strictly the same time to execute, preventing [[timing attack]]s.\n* Modify and extend legacy code written for IBM mainframe computers.<ref>{{Cite web|url=http://www.edwardbosworth.com/My3121Textbook_HTM/MyText3121_Ch01_V01.htm|title=Chapter 1 \u2013 Why Study Assembly Language|website=www.edwardbosworth.com|access-date=2016-06-01}}</ref>\n* Situations where complete control over the environment is required, in extremely high security situations where [[Trusting trust#Reflections on Trusting Trust|nothing can be taken for granted]].\n* [[Computer virus]]es, [[bootloader]]s, certain [[device driver]]s, or other items very close to the hardware or low-level operating system.\n*  [[Instruction set simulator]]s for monitoring, tracing and [[debugging]] where additional overhead is kept to a minimum\n* Situations where no high-level language exists, on a new or specialized processor for which no [[cross compiler]] is available.\n* [[Reverse-engineering]] and modifying program files such as\n**existing [[binary file|binaries]] that may or may not have originally been written in a high-level language, for example when trying to recreate programs for which source code is not available or has been lost, or cracking copy protection of proprietary software.\n** [[Video game]]s (also termed [[ROM hacking]]), which is possible via several methods. The most widely employed method is altering program code at the assembly language level.\n\nAssembly language is still taught in most [[computer science]] and [[electronic engineering]] programs. Although few programmers today regularly work with assembly language as a tool, the underlying concepts remain important. Such fundamental topics as [[binary arithmetic]], [[memory allocation]], [[stack (data structure)|stack processing]], [[character set]] encoding, [[interrupt]] processing, and [[compiler]] design would be hard to study in detail without a grasp of how a computer operates at the hardware level. Since a computer's behavior is fundamentally defined by its instruction set, the logical way to learn such concepts is to study an assembly language. Most modern computers have similar instruction sets. Therefore, studying a single assembly language is sufficient to learn: I) the basic concepts; II) to recognize situations where the use of assembly language might be appropriate; and III) to see how efficient executable code can be created from high-level languages.<ref>{{cite web|url=http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/fwd.html|title=Foreword (\"Why would anyone learn this stuff?\"), ''op. cit.''|date=1996-09-30|accessdate=2010-03-05|author=Hyde, Randall|archiveurl=https://web.archive.org/web/20100325155048/http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/fwd.html|archivedate=2010-03-25|url-status=dead}}</ref>\n'''\n\n===Typical applications===\n\n*Assembly language is typically used in a system's [[Booting|boot]] code, the low-level code that initializes and tests the system hardware prior to booting the operating system and is often stored in [[Read-only memory|ROM]].  ([[BIOS]] on IBM-compatible [[Personal Computer|PC]] systems and [[CP/M]] is an example.)\n*Some compilers translate high-level languages into assembly first before fully compiling, allowing the assembly code to be viewed for [[debug]]ging and optimization purposes.\n*Some compilers for relatively low-level languages, such as [[Pascal (programming language)|Pascal]] or [[C (programming language)|C]], allow the programmer to embed assembly language directly in the source code. Programs using such facilities can then construct abstractions using different assembly language on each hardware platform. The system's [[software portability|portable]] code can then use these processor-specific components through a uniform interface.\n*Assembly language is useful in [[reverse engineering]]. Many programs are distributed only in machine code form which is straightforward to translate into assembly language, but more difficult to translate into a higher-level language. Tools such as the [[Interactive Disassembler]] make extensive use of disassembly for such a purpose. This technique is used by hackers to crack commercial software, and competitors to produce software with similar results from competing companies.\n*Assembly language is used to enhance speed of execution, especially in early Personal Computers with limited processing power and RAM.\n*Assemblers can be used to generate blocks of data, with no high-level language overhead, from formatted and commented source code, to be used by other code.\n\n", "attributes": [{"name": "cite web\n   ", "values": [{"name": "url", "value": "https://hackaday.com/2018/08/21/kathleen-booth-assembling-early-computers-while-inventing-assembly"}, {"name": "title", "value": "Kathleen Booth: Assembling Early Computers While Inventing Assembly"}, {"name": "accessdate", "value": "February 10, 2019"}]}, {"name": "cite journal\n   ", "values": [{"name": "author1", "value": "Andrew D. Booth"}, {"name": "author2", "value": "Kathleen H. V. Britten"}, {"name": "journal", "value": "Birkbeck College, London"}, {"name": "date", "value": "September 1947"}, {"name": "url", "value": "http://mt-archive.info/Booth-1947.pdf"}, {"name": "accessdate", "value": "10 February 2019"}, {"name": "title", "value": "General considerations in the design of an all purpose electronic digital computer (Coding for the ARC, 2nd ed)"}, {"name": "quote", "value": "The non-original ideas, contained in the following text, have been derived from a number of sources, ... It is felt, however, that acknowledgement should be made to Prof. John von Neumann and to Dr. Herman Goldstein for many fruitful discussions ..."}]}, {"name": "cite journal ", "values": [{"name": "last1", "value": "Campbell-Kelly"}, {"name": "first1", "value": "Martin"}, {"name": "title", "value": "The Development of Computer Programming in Britain (1945 to 1955)"}, {"name": "journal", "value": "IEEE Annals of the History of Computing"}, {"name": "date", "value": "April 1982"}, {"name": "volume", "value": "4"}, {"name": "issue", "value": "2"}, {"name": "pages", "value": "121\u2013139"}, {"name": "doi", "value": "10.1109/MAHC.1982.10016"}]}, {"name": "cite book ", "values": [{"name": "last1", "value": "Salomon"}, {"name": "title", "value": "Assemblers and Loaders"}, {"name": "url", "value": "http://www.davidsalomon.name/assem.advertis/asl.pdf"}, {"name": "accessdate", "value": "2012-01-17"}, {"name": "page", "value": "7"}]}, {"name": "cite journal", "values": [{"name": "first", "value": "Martin"}, {"name": "last", "value": "Campbell-Kelly"}, {"name": "title", "value": "Programming the EDSAC"}, {"name": "journal", "value": "IEEE Annals of the History of Computing"}, {"name": "year", "value": "1980"}, {"name": "volume", "value": "2"}, {"name": "number", "value": "1"}, {"name": "pages", "value": "7\u201336"}, {"name": "doi", "value": "10.1109/MAHC.1980.10009"}]}, {"name": "cite journal", "values": [{"name": "first", "value": "Maurice V."}, {"name": "last", "value": "Wilkes"}, {"name": "authorlink", "value": "Maurice Wilkes"}, {"name": "title", "value": "The EDSAC \u2013 an Electronic Calculating Machine"}, {"name": "journal", "value": "Journal of Scientific Instruments"}, {"name": "year", "value": "1949"}, {"name": "volume", "value": "26"}, {"name": "issue", "value": "12"}, {"name": "pages", "value": "385\u2013391"}, {"name": "doi", "value": "10.1088/0950-7671/26/12/301"}]}, {"name": "cite web ", "values": [{"name": "url", "value": "http://www.columbia.edu/cu/computinghistory/650.html"}, {"name": "title", "value": "The IBM 650 Magnetic Drum Calculator"}, {"name": "accessdate", "value": "2012-01-17"}]}, {"name": "Cite web ", "values": [{"name": "url", "value": "http://www.eidolons-inn.net/tiki-index.php?page=SegaBase+Saturn"}, {"name": "title", "value": "Eidolon's Inn: SegaBase Saturn<!-- Bot generated title -->"}, {"name": "access-date", "value": "2008-07-25"}, {"name": "archive-url", "value": "https://web.archive.org/web/20080713074116/http://www.eidolons-inn.net/tiki-index.php?page=SegaBase+Saturn"}, {"name": "archive-date", "value": "2008-07-13"}, {"name": "url-status", "value": "dead"}]}, {"name": "cite book\n   ", "values": [{"name": "title", "value": "Windows Assembly Language and Systems Programming: 16- and 32-Bit"}, {"name": "url", "value": "https://books.google.com/books?isbn=1482275724"}, {"name": "isbn", "value": "978-1482275728"}, {"name": "author", "value": "Barry Kauler"}, {"name": "date", "value": "1997"}, {"name": "quote", "value": "Always the debate rages about the applicability of assembly language in our modern programming world."}]}, {"name": "cite web\n   ", "values": [{"name": "url", "value": "http://icps.u-strasbg.fr/~bastoul/local_copies/hsieh.html"}, {"name": "title", "value": "Programming Optimization"}, {"name": "author", "value": "Paul Hsieh"}, {"name": "quote", "value": "... design changes tend to affect performance more than ... one should not skip straight to assembly language until ..."}]}, {"name": "As of", "values": [{"name": "1", "value": "2017"}, {"name": "2", "value": "07"}]}, {"name": "cite news", "values": [{"name": "url", "value": "http://www.tiobe.com/tiobe_index"}, {"name": "title", "value": "TIOBE Index"}, {"name": "publisher", "value": "TIOBE Software"}]}, {"name": "cite web", "values": [{"name": "last", "value": "Rusling"}, {"name": "first", "value": "David A."}, {"name": "title", "value": "The Linux Kernel"}, {"name": "url", "value": "http://tldp.org/LDP/tlk/basics/sw.html"}, {"name": "accessdate", "value": "Mar 11, 2012"}]}, {"name": "cite news", "values": [{"name": "url", "value": "https://www.nytimes.com/2005/11/28/technology/28super.html?_r=1"}, {"name": "title", "value": "Writing the Fastest Code, by Hand, for Fun: A Human Computer Keeps Speeding Up Chips"}, {"name": "publisher", "value": "New York Times, John Markoff"}, {"name": "date", "value": "2005-11-28"}, {"name": "accessdate", "value": "2010-03-04"}]}, {"name": "cite web ", "values": [{"name": "url", "value": "http://hardwarebug.org/2010/01/30/bit-field-badness/"}, {"name": "title", "value": "Bit-field-badness"}, {"name": "publisher", "value": "hardwarebug.org"}, {"name": "date", "value": "2010-01-30"}, {"name": "accessdate", "value": "2010-03-04"}, {"name": "archiveurl", "value": "https://web.archive.org/web/20100205120952/http://hardwarebug.org/2010/01/30/bit-field-badness/"}, {"name": "archivedate", "value": "2010-02-05"}, {"name": "url-status", "value": "dead"}]}, {"name": "cite web ", "values": [{"name": "url", "value": "http://hardwarebug.org/2009/05/13/gcc-makes-a-mess/"}, {"name": "title", "value": "GCC makes a mess"}, {"name": "publisher", "value": "HardwareBug.org"}, {"name": "date", "value": "2009-05-13"}, {"name": "accessdate", "value": "2010-03-04"}, {"name": "archiveurl", "value": "https://web.archive.org/web/20100316212040/http://hardwarebug.org/2009/05/13/gcc-makes-a-mess/"}, {"name": "archivedate", "value": "2010-03-16"}, {"name": "url-status", "value": "dead"}]}, {"name": "cite web", "values": [{"name": "url", "value": "http://webster.cs.ucr.edu/Page_TechDocs/GreatDebate/debate1.html"}, {"name": "title", "value": "The Great Debate"}, {"name": "accessdate", "value": "2008-07-03"}, {"name": "author", "value": "Randall Hyde"}, {"name": "archiveurl", "value": "https://web.archive.org/web/20080616110102/http://webster.cs.ucr.edu/Page_TechDocs/GreatDebate/debate1.html"}, {"name": "archivedate", "value": "2008-06-16"}, {"name": "url-status", "value": "dead"}]}, {"name": "cite web ", "values": [{"name": "url", "value": "http://hardwarebug.org/2008/11/28/codesourcery-fails-again/"}, {"name": "title", "value": "Code sourcery fails again"}, {"name": "publisher", "value": "hardwarebug.org"}, {"name": "date", "value": "2010-01-30"}, {"name": "accessdate", "value": "2010-03-04"}, {"name": "archiveurl", "value": "https://web.archive.org/web/20100402221204/http://hardwarebug.org/2008/11/28/codesourcery-fails-again/"}, {"name": "archivedate", "value": "2010-04-02"}, {"name": "url-status", "value": "dead"}]}, {"name": "cite web", "values": [{"name": "last", "value": "Click"}, {"name": "first", "value": "Cliff"}, {"name": "title", "value": "A Crash Course in Modern Hardware"}, {"name": "url", "value": "http://www.infoq.com/presentations/click-crash-course-modern-hardware"}, {"name": "accessdate", "value": "May 1, 2014"}]}, {"name": "cite web", "values": [{"name": "url", "value": "http://tifreakware.net/tutorials/89/a/calc/fargoii.htm"}, {"name": "title", "value": "68K Programming in Fargo II"}, {"name": "accessdate", "value": "2008-07-03"}, {"name": "archiveurl", "value": "https://web.archive.org/web/20080702181616/http://tifreakware.net/tutorials/89/a/calc/fargoii.htm"}, {"name": "archivedate", "value": "2 July 2008"}, {"name": "url-status", "value": "live"}]}, {"name": "cite web", "values": [{"name": "url", "value": "http://eigen.tuxfamily.org/index.php?title=Benchmark-August2008"}, {"name": "title", "value": "BLAS Benchmark-August2008"}, {"name": "publisher", "value": "eigen.tuxfamily.org"}, {"name": "date", "value": "2008-08-01"}, {"name": "accessdate", "value": "2010-03-04"}]}, {"name": "cite web ", "values": [{"name": "url", "value": "http://git.videolan.org/?p=x264.git;a=tree;f=common/x86;hb=HEAD"}, {"name": "title", "value": "x264.git/common/x86/dct-32.asm"}, {"name": "publisher", "value": "git.videolan.org"}, {"name": "date", "value": "2010-09-29"}, {"name": "accessdate", "value": "2010-09-29"}, {"name": "archive-url", "value": "https://web.archive.org/web/20120304083653/http://git.videolan.org/?p=x264.git%3Ba%3Dtree%3Bf%3Dcommon%2Fx86%3Bhb%3DHEAD"}, {"name": "archive-date", "value": "2012-03-04"}, {"name": "url-status", "value": "dead"}]}, {"name": "Cite web", "values": [{"name": "url", "value": "http://www.edwardbosworth.com/My3121Textbook_HTM/MyText3121_Ch01_V01.htm"}, {"name": "title", "value": "Chapter 1 \u2013 Why Study Assembly Language"}, {"name": "website", "value": "www.edwardbosworth.com"}, {"name": "access-date", "value": "2016-06-01"}]}, {"name": "cite web", "values": [{"name": "url", "value": "http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/fwd.html"}, {"name": "title", "value": "Foreword (\"Why would anyone learn this stuff?\"), ''op. cit.''"}, {"name": "date", "value": "1996-09-30"}, {"name": "accessdate", "value": "2010-03-05"}, {"name": "author", "value": "Hyde, Randall"}, {"name": "archiveurl", "value": "https://web.archive.org/web/20100325155048/http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/fwd.html"}, {"name": "archivedate", "value": "2010-03-25"}, {"name": "url-status", "value": "dead"}]}], "id": 15}, {"title": "Historical perspective", "paragraphs": "Assembly languages were not available at the time when the [[stored-program computer]] was introduced. [[Kathleen Booth]] \"is credited with inventing\nassembly language\"<ref name=ClarityBooth>{{cite web\n   |url=https://hackaday.com/2018/08/21/kathleen-booth-assembling-early-computers-while-inventing-assembly\n   |title=Kathleen Booth: Assembling Early Computers While Inventing Assembly\n   |accessdate=February 10, 2019}}</ref><ref name=Booth1947.pdf>{{cite journal\n   |author1=Andrew D. Booth  |author2=Kathleen H. V. Britten\n   |journal=Birkbeck College, London |date=September 1947\n   |url=http://mt-archive.info/Booth-1947.pdf\n   |accessdate=10 February 2019\n   |title=General considerations in the design of an all purpose electronic digital computer (Coding for the ARC, 2nd ed)\n  |quote=The non-original ideas, contained in the following text, have been derived from a number of sources, ... It is felt, however, that acknowledgement should be made to Prof. John von Neumann and to Dr. Herman Goldstein for many fruitful discussions ...}}</ref><ref>see TALK page for details</ref> based on theoretical work she began in 1947, while working on the [[APEXC|ARC2]] at [[Birkbeck, University of London]] following consultation by [[Andrew Donald Booth|Andrew Booth]] (later her husband) with mathematician [[John von Neumann]] and physicist [[Herman Goldstine]] at the [[Institute for Advanced Study]].<ref name=Booth1947.pdf/><ref name=\"birkbeck\">{{cite journal |last1=Campbell-Kelly|first1=Martin|title=The Development of Computer Programming in Britain (1945 to 1955)\n   |journal=IEEE Annals of the History of Computing |date=April 1982 |volume=4  \n   |issue=2 |pages=121\u2013139 |doi=10.1109/MAHC.1982.10016}}</ref> \n\nIn late 1948, the [[Electronic Delay Storage Automatic Calculator]] (EDSAC) had an assembler (named \"initial orders\") integrated into its [[Booting|bootstrap]] program. It used one-letter mnemonics developed by [[David Wheeler (computer scientist)|David Wheeler]], who is credited by the IEEE Computer Society as the creator of the first \"assembler.\"<ref>{{cite book | last1 = Salomon | title = Assemblers and Loaders | url = http://www.davidsalomon.name/assem.advertis/asl.pdf | accessdate = 2012-01-17 | page = 7 }}</ref><ref>{{cite journal|first=Martin|last=Campbell-Kelly|title=Programming the EDSAC|journal=IEEE Annals of the History of Computing|year=1980|volume=2|number=1|pages=7\u201336|doi=10.1109/MAHC.1980.10009}}</ref> <ref>https://www.computer.org/web/awards/pioneer-david-wheeler 1985 Computer Pioneer Award 'For assembly language programming' David Wheeler</ref> Reports on the EDSAC introduced the term \"assembly\" for the process of combining fields into an instruction word.<ref>{{cite journal|first=Maurice V.|last=Wilkes|authorlink=Maurice Wilkes|title=The EDSAC \u2013 an Electronic Calculating Machine|journal=Journal of Scientific Instruments|year=1949|volume=26|issue=12|pages=385\u2013391|doi=10.1088/0950-7671/26/12/301}}</ref> SOAP (Symbolic Optimal Assembly Program) was an assembly language for the [[IBM 650]] computer written by Stan Poley in 1955.<ref>{{cite web |url=http://www.columbia.edu/cu/computinghistory/650.html |title=The IBM 650 Magnetic Drum Calculator |accessdate=2012-01-17}}</ref>\n\nAssembly languages eliminate much of the error-prone, tedious, and time-consuming [[first-generation language|first-generation]] programming needed with the earliest computers, freeing programmers from tedium such as remembering numeric codes and calculating addresses. They were once widely used for all sorts of programming. However, by the 1980s (1990s on [[microcomputer]]s), their use had largely been supplanted by higher-level languages, in the search for improved [[programming productivity]]. Today assembly language is still used for direct hardware manipulation, access to specialized processor instructions, or to address critical performance issues. Typical uses are [[device driver]]s, low-level [[embedded system]]s, and [[real-time computing|real-time]] systems.\n\nHistorically, numerous programs have been written entirely in assembly language. The [[Burroughs MCP]] (1961) was the first computer for which an operating system was not developed entirely in assembly language; it was written in [[Executive Systems Problem Oriented Language]] (ESPOL), an Algol dialect. Many commercial applications were written in assembly language as well, including a large amount of the [[IBM mainframe]] software written by large corporations. [[COBOL]], [[FORTRAN]] and some [[PL/I]] eventually displaced much of this work, although a number of large organizations retained assembly-language application infrastructures well into the 1990s.\n\nMost early microcomputers relied on hand-coded assembly language, including most operating systems and large applications. This was because these systems had severe resource constraints, imposed idiosyncratic memory and display architectures, and provided limited, buggy system services. Perhaps more important was the lack of first-class high-level language compilers suitable for microcomputer use. A psychological factor may have also played a role: the first generation of microcomputer programmers retained a hobbyist, \"wires and pliers\" attitude.\n\nIn a more commercial context, the biggest reasons for using assembly language were minimal bloat (size), minimal overhead, greater speed, and reliability.\n\nTypical examples of large assembly language programs from this time are IBM PC [[DOS]] operating systems, the [[Turbo Pascal]] compiler and early applications such as the [[spreadsheet]] program [[Lotus 1-2-3]]. Assembly language was used to get the best performance out of the [[Sega Saturn]], a console that was notoriously challenging to develop and program games for.<ref>{{Cite web |url=http://www.eidolons-inn.net/tiki-index.php?page=SegaBase+Saturn |title=Eidolon's Inn: SegaBase Saturn<!-- Bot generated title --> |access-date=2008-07-25 |archive-url=https://web.archive.org/web/20080713074116/http://www.eidolons-inn.net/tiki-index.php?page=SegaBase+Saturn |archive-date=2008-07-13 |url-status=dead }}</ref> The 1993 arcade game ''[[NBA Jam (1993 video game)|NBA Jam]]'' is another example.\n\nAssembly language has long been the primary development language for many popular home computers of the 1980s and 1990s (such as the [[MSX]],  [[Sinclair Research|Sinclair]] [[ZX Spectrum]], [[Commodore 64]], [[Commodore Amiga]], and [[Atari ST]]). This was in large part because [[Interpreted language|interpreted]] BASIC dialects on these systems offered insufficient execution speed, as well as insufficient facilities to take full advantage of the available hardware on these systems. Some systems even have an [[integrated development environment]] (IDE) with highly advanced debugging and macro facilities. Some compilers available for the [[Radio Shack]] [[TRS-80]] and its successors had the capability to combine inline assembly source with high-level program statements. Upon compilation a built-in assembler produced inline machine code.\n\n", "attributes": [{"name": "cite web\n   ", "values": [{"name": "url", "value": "https://hackaday.com/2018/08/21/kathleen-booth-assembling-early-computers-while-inventing-assembly"}, {"name": "title", "value": "Kathleen Booth: Assembling Early Computers While Inventing Assembly"}, {"name": "accessdate", "value": "February 10, 2019"}]}, {"name": "cite journal\n   ", "values": [{"name": "author1", "value": "Andrew D. Booth"}, {"name": "author2", "value": "Kathleen H. V. Britten"}, {"name": "journal", "value": "Birkbeck College, London"}, {"name": "date", "value": "September 1947"}, {"name": "url", "value": "http://mt-archive.info/Booth-1947.pdf"}, {"name": "accessdate", "value": "10 February 2019"}, {"name": "title", "value": "General considerations in the design of an all purpose electronic digital computer (Coding for the ARC, 2nd ed)"}, {"name": "quote", "value": "The non-original ideas, contained in the following text, have been derived from a number of sources, ... It is felt, however, that acknowledgement should be made to Prof. John von Neumann and to Dr. Herman Goldstein for many fruitful discussions ..."}]}, {"name": "cite journal ", "values": [{"name": "last1", "value": "Campbell-Kelly"}, {"name": "first1", "value": "Martin"}, {"name": "title", "value": "The Development of Computer Programming in Britain (1945 to 1955)"}, {"name": "journal", "value": "IEEE Annals of the History of Computing"}, {"name": "date", "value": "April 1982"}, {"name": "volume", "value": "4"}, {"name": "issue", "value": "2"}, {"name": "pages", "value": "121\u2013139"}, {"name": "doi", "value": "10.1109/MAHC.1982.10016"}]}, {"name": "cite book ", "values": [{"name": "last1", "value": "Salomon"}, {"name": "title", "value": "Assemblers and Loaders"}, {"name": "url", "value": "http://www.davidsalomon.name/assem.advertis/asl.pdf"}, {"name": "accessdate", "value": "2012-01-17"}, {"name": "page", "value": "7"}]}, {"name": "cite journal", "values": [{"name": "first", "value": "Martin"}, {"name": "last", "value": "Campbell-Kelly"}, {"name": "title", "value": "Programming the EDSAC"}, {"name": "journal", "value": "IEEE Annals of the History of Computing"}, {"name": "year", "value": "1980"}, {"name": "volume", "value": "2"}, {"name": "number", "value": "1"}, {"name": "pages", "value": "7\u201336"}, {"name": "doi", "value": "10.1109/MAHC.1980.10009"}]}, {"name": "cite journal", "values": [{"name": "first", "value": "Maurice V."}, {"name": "last", "value": "Wilkes"}, {"name": "authorlink", "value": "Maurice Wilkes"}, {"name": "title", "value": "The EDSAC \u2013 an Electronic Calculating Machine"}, {"name": "journal", "value": "Journal of Scientific Instruments"}, {"name": "year", "value": "1949"}, {"name": "volume", "value": "26"}, {"name": "issue", "value": "12"}, {"name": "pages", "value": "385\u2013391"}, {"name": "doi", "value": "10.1088/0950-7671/26/12/301"}]}, {"name": "cite web ", "values": [{"name": "url", "value": "http://www.columbia.edu/cu/computinghistory/650.html"}, {"name": "title", "value": "The IBM 650 Magnetic Drum Calculator"}, {"name": "accessdate", "value": "2012-01-17"}]}, {"name": "Cite web ", "values": [{"name": "url", "value": "http://www.eidolons-inn.net/tiki-index.php?page=SegaBase+Saturn"}, {"name": "title", "value": "Eidolon's Inn: SegaBase Saturn<!-- Bot generated title -->"}, {"name": "access-date", "value": "2008-07-25"}, {"name": "archive-url", "value": "https://web.archive.org/web/20080713074116/http://www.eidolons-inn.net/tiki-index.php?page=SegaBase+Saturn"}, {"name": "archive-date", "value": "2008-07-13"}, {"name": "url-status", "value": "dead"}]}], "id": 16}, {"title": "Current usage", "paragraphs": "There have always<ref>{{cite book\n   |title=Windows Assembly Language and Systems Programming: 16- and 32-Bit\n   |url=https://books.google.com/books?isbn=1482275724  |isbn=978-1482275728  \n   |author=Barry Kauler  |date=1997\n   |quote=Always the debate rages about the applicability of assembly language in our modern programming world.}}</ref> been debates over the usefulness and performance of assembly language relative to high-level languages. \n\nAlthough assembly language has specific niche uses where it is important (see below), there are other tools for optimization.<ref>{{cite web\n   |url=http://icps.u-strasbg.fr/~bastoul/local_copies/hsieh.html\n   |title=Programming Optimization\n   |author=Paul Hsieh  \n   |quote=... design changes tend to affect performance more than ... one should not skip straight to assembly language until ...}}</ref>\n\n{{As of|2017|07}}, the [[TIOBE index]] of programming language popularity ranks assembly language at 11, ahead of [[Visual Basic]], for example.<ref name=\"tiobe\">{{cite news|url=http://www.tiobe.com/tiobe_index |title=TIOBE Index|publisher=TIOBE Software}}</ref> Assembler can be used to optimize for speed or optimize for size. In the case of speed optimization, modern [[optimizing compiler]]s are claimed<ref>{{cite web|last=Rusling|first=David A.|title=The Linux Kernel|url=http://tldp.org/LDP/tlk/basics/sw.html|accessdate=Mar 11, 2012}}</ref>  to render high-level languages into code that can run as fast as hand-written assembly, despite the counter-examples that can be found.<ref name=\"goto\">{{cite news|url=https://www.nytimes.com/2005/11/28/technology/28super.html?_r=1 |title=Writing the Fastest Code, by Hand, for Fun: A Human Computer Keeps Speeding Up Chips |publisher=New York Times, John Markoff |date=2005-11-28 |accessdate=2010-03-04}}</ref><ref name=\"bit-fild\">{{cite web |url=http://hardwarebug.org/2010/01/30/bit-field-badness/ |title=Bit-field-badness |publisher=hardwarebug.org |date=2010-01-30 |accessdate=2010-03-04 |archiveurl=https://web.archive.org/web/20100205120952/http://hardwarebug.org/2010/01/30/bit-field-badness/ |archivedate=2010-02-05 |url-status=dead }}</ref><ref name=\"gcc-mess\">{{cite web |url=http://hardwarebug.org/2009/05/13/gcc-makes-a-mess/ |title=GCC makes a mess |publisher=HardwareBug.org |date=2009-05-13 |accessdate=2010-03-04 |archiveurl=https://web.archive.org/web/20100316212040/http://hardwarebug.org/2009/05/13/gcc-makes-a-mess/ |archivedate=2010-03-16 |url-status=dead }}</ref> The complexity of modern processors and memory sub-systems makes effective optimization increasingly difficult for compilers, as well as for assembly programmers.<ref name=\"GreatDebate1\">{{cite web|url=http://webster.cs.ucr.edu/Page_TechDocs/GreatDebate/debate1.html|title=The Great Debate|accessdate=2008-07-03|author=Randall Hyde|archiveurl=https://web.archive.org/web/20080616110102/http://webster.cs.ucr.edu/Page_TechDocs/GreatDebate/debate1.html|archivedate=2008-06-16|url-status=dead}}</ref><ref name=\"compiler-fails1\">{{cite web |url=http://hardwarebug.org/2008/11/28/codesourcery-fails-again/ |title=Code sourcery fails again |publisher=hardwarebug.org |date=2010-01-30 |accessdate=2010-03-04 |archiveurl=https://web.archive.org/web/20100402221204/http://hardwarebug.org/2008/11/28/codesourcery-fails-again/ |archivedate=2010-04-02 |url-status=dead }}</ref> Moreover, increasing processor performance has meant that most CPUs sit idle most of the time,<ref>{{cite web|last=Click|first=Cliff|title=A Crash Course in Modern Hardware|url=http://www.infoq.com/presentations/click-crash-course-modern-hardware|accessdate=May 1, 2014}}</ref> with delays caused by predictable bottlenecks such as cache misses, [[I/O]] operations and [[paging]]. This has made raw code execution speed a non-issue for many programmers.\n\nThere are some situations in which developers might choose to use assembly language:\n* Writing code for systems with older processors that have limited high-level language options such as the [[Atari 2600]], [[Commodore 64]], and [[graphing calculators]].<ref>{{cite web|url=http://tifreakware.net/tutorials/89/a/calc/fargoii.htm|title=68K Programming in Fargo II|accessdate=2008-07-03| archiveurl= https://web.archive.org/web/20080702181616/http://tifreakware.net/tutorials/89/a/calc/fargoii.htm| archivedate= 2 July 2008 | url-status= live}}</ref>\n* Code that must interact directly with the hardware, for example in [[device driver]]s and [[interrupt handler]]s.\n* In an embedded processor or DSP, high-repetition interrupts require the shortest number of cycles per interrupt, such as an interrupt that occurs 1000 or 10000 times a second.\n* Programs that need to use processor-specific instructions not implemented in a compiler. A common example is the [[circular shift|bitwise rotation]] instruction at the core of many encryption algorithms, as well as querying the parity of a byte or the 4-bit carry of an addition.\n* A stand-alone executable of compact size is required that must execute without recourse to the [[Run-time system|run-time]] components or [[library (computing)|libraries]] associated with a high-level language. Examples have included firmware for telephones, automobile fuel and ignition systems, air-conditioning control systems, security systems, and sensors.\n* Programs with performance-sensitive inner loops, where assembly language provides optimization opportunities that are difficult to achieve in a high-level language. For example, [[linear algebra]] with [[Basic Linear Algebra Subprograms|BLAS]]<ref name=\"goto\"/><ref name=\"bench\">{{cite web|url=http://eigen.tuxfamily.org/index.php?title=Benchmark-August2008 |title=BLAS Benchmark-August2008 |publisher=eigen.tuxfamily.org |date=2008-08-01 |accessdate=2010-03-04}}</ref> or [[DCT (math)|discrete cosine transformation]] (e.g. [[SIMD]] assembly version from [[x264]]<ref>{{cite web |url=http://git.videolan.org/?p=x264.git;a=tree;f=common/x86;hb=HEAD |title=x264.git/common/x86/dct-32.asm |publisher=git.videolan.org |date=2010-09-29 |accessdate=2010-09-29 |archive-url=https://web.archive.org/web/20120304083653/http://git.videolan.org/?p=x264.git%3Ba%3Dtree%3Bf%3Dcommon%2Fx86%3Bhb%3DHEAD |archive-date=2012-03-04 |url-status=dead }}</ref>).\n* Programs that create vectorized functions for programs in higher-level languages such as C.  In the higher-level language this is sometimes aided by compiler [[intrinsic function]]s which map directly to SIMD mnemonics, but nevertheless result in a one-to-one assembly conversion specific for the given vector processor.\n* [[real-time computing|Real-time]] programs such as simulations, flight navigation systems, and medical equipment. For example, in a [[fly-by-wire]] system, telemetry must be interpreted and acted upon within strict time constraints. Such systems must eliminate sources of unpredictable delays, which may be created by (some) interpreted languages, automatic [[garbage collection (computer science)|garbage collection]], paging operations, or [[preemptive multitasking]]. However, some higher-level languages incorporate run-time components and operating system interfaces that can introduce such delays. Choosing assembly or [[lower level language]]s for such systems gives programmers greater visibility and control over processing details.\n* Cryptographic algorithms that must always take strictly the same time to execute, preventing [[timing attack]]s.\n* Modify and extend legacy code written for IBM mainframe computers.<ref>{{Cite web|url=http://www.edwardbosworth.com/My3121Textbook_HTM/MyText3121_Ch01_V01.htm|title=Chapter 1 \u2013 Why Study Assembly Language|website=www.edwardbosworth.com|access-date=2016-06-01}}</ref>\n* Situations where complete control over the environment is required, in extremely high security situations where [[Trusting trust#Reflections on Trusting Trust|nothing can be taken for granted]].\n* [[Computer virus]]es, [[bootloader]]s, certain [[device driver]]s, or other items very close to the hardware or low-level operating system.\n*  [[Instruction set simulator]]s for monitoring, tracing and [[debugging]] where additional overhead is kept to a minimum\n* Situations where no high-level language exists, on a new or specialized processor for which no [[cross compiler]] is available.\n* [[Reverse-engineering]] and modifying program files such as\n**existing [[binary file|binaries]] that may or may not have originally been written in a high-level language, for example when trying to recreate programs for which source code is not available or has been lost, or cracking copy protection of proprietary software.\n** [[Video game]]s (also termed [[ROM hacking]]), which is possible via several methods. The most widely employed method is altering program code at the assembly language level.\n\nAssembly language is still taught in most [[computer science]] and [[electronic engineering]] programs. Although few programmers today regularly work with assembly language as a tool, the underlying concepts remain important. Such fundamental topics as [[binary arithmetic]], [[memory allocation]], [[stack (data structure)|stack processing]], [[character set]] encoding, [[interrupt]] processing, and [[compiler]] design would be hard to study in detail without a grasp of how a computer operates at the hardware level. Since a computer's behavior is fundamentally defined by its instruction set, the logical way to learn such concepts is to study an assembly language. Most modern computers have similar instruction sets. Therefore, studying a single assembly language is sufficient to learn: I) the basic concepts; II) to recognize situations where the use of assembly language might be appropriate; and III) to see how efficient executable code can be created from high-level languages.<ref>{{cite web|url=http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/fwd.html|title=Foreword (\"Why would anyone learn this stuff?\"), ''op. cit.''|date=1996-09-30|accessdate=2010-03-05|author=Hyde, Randall|archiveurl=https://web.archive.org/web/20100325155048/http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/fwd.html|archivedate=2010-03-25|url-status=dead}}</ref>\n'''\n\n", "attributes": [{"name": "cite book\n   ", "values": [{"name": "title", "value": "Windows Assembly Language and Systems Programming: 16- and 32-Bit"}, {"name": "url", "value": "https://books.google.com/books?isbn=1482275724"}, {"name": "isbn", "value": "978-1482275728"}, {"name": "author", "value": "Barry Kauler"}, {"name": "date", "value": "1997"}, {"name": "quote", "value": "Always the debate rages about the applicability of assembly language in our modern programming world."}]}, {"name": "cite web\n   ", "values": [{"name": "url", "value": "http://icps.u-strasbg.fr/~bastoul/local_copies/hsieh.html"}, {"name": "title", "value": "Programming Optimization"}, {"name": "author", "value": "Paul Hsieh"}, {"name": "quote", "value": "... design changes tend to affect performance more than ... one should not skip straight to assembly language until ..."}]}, {"name": "As of", "values": [{"name": "1", "value": "2017"}, {"name": "2", "value": "07"}]}, {"name": "cite news", "values": [{"name": "url", "value": "http://www.tiobe.com/tiobe_index"}, {"name": "title", "value": "TIOBE Index"}, {"name": "publisher", "value": "TIOBE Software"}]}, {"name": "cite web", "values": [{"name": "last", "value": "Rusling"}, {"name": "first", "value": "David A."}, {"name": "title", "value": "The Linux Kernel"}, {"name": "url", "value": "http://tldp.org/LDP/tlk/basics/sw.html"}, {"name": "accessdate", "value": "Mar 11, 2012"}]}, {"name": "cite news", "values": [{"name": "url", "value": "https://www.nytimes.com/2005/11/28/technology/28super.html?_r=1"}, {"name": "title", "value": "Writing the Fastest Code, by Hand, for Fun: A Human Computer Keeps Speeding Up Chips"}, {"name": "publisher", "value": "New York Times, John Markoff"}, {"name": "date", "value": "2005-11-28"}, {"name": "accessdate", "value": "2010-03-04"}]}, {"name": "cite web ", "values": [{"name": "url", "value": "http://hardwarebug.org/2010/01/30/bit-field-badness/"}, {"name": "title", "value": "Bit-field-badness"}, {"name": "publisher", "value": "hardwarebug.org"}, {"name": "date", "value": "2010-01-30"}, {"name": "accessdate", "value": "2010-03-04"}, {"name": "archiveurl", "value": "https://web.archive.org/web/20100205120952/http://hardwarebug.org/2010/01/30/bit-field-badness/"}, {"name": "archivedate", "value": "2010-02-05"}, {"name": "url-status", "value": "dead"}]}, {"name": "cite web ", "values": [{"name": "url", "value": "http://hardwarebug.org/2009/05/13/gcc-makes-a-mess/"}, {"name": "title", "value": "GCC makes a mess"}, {"name": "publisher", "value": "HardwareBug.org"}, {"name": "date", "value": "2009-05-13"}, {"name": "accessdate", "value": "2010-03-04"}, {"name": "archiveurl", "value": "https://web.archive.org/web/20100316212040/http://hardwarebug.org/2009/05/13/gcc-makes-a-mess/"}, {"name": "archivedate", "value": "2010-03-16"}, {"name": "url-status", "value": "dead"}]}, {"name": "cite web", "values": [{"name": "url", "value": "http://webster.cs.ucr.edu/Page_TechDocs/GreatDebate/debate1.html"}, {"name": "title", "value": "The Great Debate"}, {"name": "accessdate", "value": "2008-07-03"}, {"name": "author", "value": "Randall Hyde"}, {"name": "archiveurl", "value": "https://web.archive.org/web/20080616110102/http://webster.cs.ucr.edu/Page_TechDocs/GreatDebate/debate1.html"}, {"name": "archivedate", "value": "2008-06-16"}, {"name": "url-status", "value": "dead"}]}, {"name": "cite web ", "values": [{"name": "url", "value": "http://hardwarebug.org/2008/11/28/codesourcery-fails-again/"}, {"name": "title", "value": "Code sourcery fails again"}, {"name": "publisher", "value": "hardwarebug.org"}, {"name": "date", "value": "2010-01-30"}, {"name": "accessdate", "value": "2010-03-04"}, {"name": "archiveurl", "value": "https://web.archive.org/web/20100402221204/http://hardwarebug.org/2008/11/28/codesourcery-fails-again/"}, {"name": "archivedate", "value": "2010-04-02"}, {"name": "url-status", "value": "dead"}]}, {"name": "cite web", "values": [{"name": "last", "value": "Click"}, {"name": "first", "value": "Cliff"}, {"name": "title", "value": "A Crash Course in Modern Hardware"}, {"name": "url", "value": "http://www.infoq.com/presentations/click-crash-course-modern-hardware"}, {"name": "accessdate", "value": "May 1, 2014"}]}, {"name": "cite web", "values": [{"name": "url", "value": "http://tifreakware.net/tutorials/89/a/calc/fargoii.htm"}, {"name": "title", "value": "68K Programming in Fargo II"}, {"name": "accessdate", "value": "2008-07-03"}, {"name": "archiveurl", "value": "https://web.archive.org/web/20080702181616/http://tifreakware.net/tutorials/89/a/calc/fargoii.htm"}, {"name": "archivedate", "value": "2 July 2008"}, {"name": "url-status", "value": "live"}]}, {"name": "cite web", "values": [{"name": "url", "value": "http://eigen.tuxfamily.org/index.php?title=Benchmark-August2008"}, {"name": "title", "value": "BLAS Benchmark-August2008"}, {"name": "publisher", "value": "eigen.tuxfamily.org"}, {"name": "date", "value": "2008-08-01"}, {"name": "accessdate", "value": "2010-03-04"}]}, {"name": "cite web ", "values": [{"name": "url", "value": "http://git.videolan.org/?p=x264.git;a=tree;f=common/x86;hb=HEAD"}, {"name": "title", "value": "x264.git/common/x86/dct-32.asm"}, {"name": "publisher", "value": "git.videolan.org"}, {"name": "date", "value": "2010-09-29"}, {"name": "accessdate", "value": "2010-09-29"}, {"name": "archive-url", "value": "https://web.archive.org/web/20120304083653/http://git.videolan.org/?p=x264.git%3Ba%3Dtree%3Bf%3Dcommon%2Fx86%3Bhb%3DHEAD"}, {"name": "archive-date", "value": "2012-03-04"}, {"name": "url-status", "value": "dead"}]}, {"name": "Cite web", "values": [{"name": "url", "value": "http://www.edwardbosworth.com/My3121Textbook_HTM/MyText3121_Ch01_V01.htm"}, {"name": "title", "value": "Chapter 1 \u2013 Why Study Assembly Language"}, {"name": "website", "value": "www.edwardbosworth.com"}, {"name": "access-date", "value": "2016-06-01"}]}, {"name": "cite web", "values": [{"name": "url", "value": "http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/fwd.html"}, {"name": "title", "value": "Foreword (\"Why would anyone learn this stuff?\"), ''op. cit.''"}, {"name": "date", "value": "1996-09-30"}, {"name": "accessdate", "value": "2010-03-05"}, {"name": "author", "value": "Hyde, Randall"}, {"name": "archiveurl", "value": "https://web.archive.org/web/20100325155048/http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/fwd.html"}, {"name": "archivedate", "value": "2010-03-25"}, {"name": "url-status", "value": "dead"}]}], "id": 17}, {"title": "Typical applications", "paragraphs": "\n*Assembly language is typically used in a system's [[Booting|boot]] code, the low-level code that initializes and tests the system hardware prior to booting the operating system and is often stored in [[Read-only memory|ROM]].  ([[BIOS]] on IBM-compatible [[Personal Computer|PC]] systems and [[CP/M]] is an example.)\n*Some compilers translate high-level languages into assembly first before fully compiling, allowing the assembly code to be viewed for [[debug]]ging and optimization purposes.\n*Some compilers for relatively low-level languages, such as [[Pascal (programming language)|Pascal]] or [[C (programming language)|C]], allow the programmer to embed assembly language directly in the source code. Programs using such facilities can then construct abstractions using different assembly language on each hardware platform. The system's [[software portability|portable]] code can then use these processor-specific components through a uniform interface.\n*Assembly language is useful in [[reverse engineering]]. Many programs are distributed only in machine code form which is straightforward to translate into assembly language, but more difficult to translate into a higher-level language. Tools such as the [[Interactive Disassembler]] make extensive use of disassembly for such a purpose. This technique is used by hackers to crack commercial software, and competitors to produce software with similar results from competing companies.\n*Assembly language is used to enhance speed of execution, especially in early Personal Computers with limited processing power and RAM.\n*Assemblers can be used to generate blocks of data, with no high-level language overhead, from formatted and commented source code, to be used by other code.\n\n", "attributes": [], "id": 18}, {"title": "See also", "paragraphs": "{{Portal|Computer programming}}\n* [[Compiler]]\n* [[Comparison of assemblers]]\n* [[Disassembler]]\n* [[Hexadecimal]]\n* [[Instruction set]]\n* [[Little man computer]] \u2013 an educational computer model with a base-10 assembly language\n* [[Nibble]]\n* [[Typed assembly language]]\n\n", "attributes": [{"name": "Portal", "values": [{"name": "1", "value": "Computer programming"}]}], "id": 19}, {"title": "Notes", "paragraphs": "{{Notelist}}\n\n", "attributes": [], "id": 20}, {"title": "References", "paragraphs": "{{Reflist|30em}}\n\n", "attributes": [{"name": "Reflist", "values": [{"name": "1", "value": "30em"}]}], "id": 21}, {"title": "Further reading", "paragraphs": "* [https://web.archive.org/web/20130602003436/http://www.asmcommunity.net/book/ ''ASM Community Book''] \"An online book full of helpful ASM info, tutorials and code examples\" by the ASM Community, archived at the internet archive.\n* Jonathan Bartlett: ''[https://web.archive.org/web/20110708061040/http://programminggroundup.blogspot.com/ Programming from the Ground Up]''. Bartlett Publishing, 2004. {{ISBN|0-9752838-4-7}}<br />Also available online [https://web.archive.org/web/20090206015549/http://download.savannah.gnu.org/releases-noredirect/pgubook/ProgrammingGroundUp-1-0-booksize.pdf as PDF]\n* Robert Britton: ''MIPS Assembly Language Programming''. Prentice Hall, 2003. {{ISBN|0-13-142044-5}}\n* Jeff Duntemann: ''Assembly Language Step-by-Step''. Wiley, 2000. {{ISBN|0-471-37523-3}}\n* Randall Hyde: ''The Art of Assembly Language''. No Starch Press, 2003. {{ISBN|1-886411-97-2}}<br />Draft versions [http://www.plantation-productions.com/Webster/www.artofasm.com/index.html available online] as PDF and HTML\n* Charles W. Kann: ''[https://web.archive.org/web/20160304070400/http://cupola.gettysburg.edu/cgi/viewcontent.cgi?article=1001&context=oer Introduction to MIPS Assembly Language Programming]''. 2015.\n* Peter Norton, John Socha, ''Peter Norton's Assembly Language Book for the IBM PC'', Brady Books, NY: 1986.\n* Michael Singer, ''PDP-11. Assembler Language Programming and Machine Organization'', John Wiley & Sons, NY: 1980.\n* Dominic Sweetman: ''See MIPS Run''. Morgan Kaufmann Publishers, 1999. {{ISBN|1-55860-410-3}}\n* John Waldron: ''Introduction to RISC Assembly Language Programming''. Addison Wesley, 1998. {{ISBN|0-201-39828-1}}\n* Dennis Yurichev: [https://yurichev.com/writings/UAL-EN.pdf ''Understanding Assembly Language'']\n\n", "attributes": [{"name": "ISBN", "values": [{"name": "1", "value": "0-9752838-4-7"}]}, {"name": "ISBN", "values": [{"name": "1", "value": "0-13-142044-5"}]}, {"name": "ISBN", "values": [{"name": "1", "value": "0-471-37523-3"}]}, {"name": "ISBN", "values": [{"name": "1", "value": "1-886411-97-2"}]}, {"name": "ISBN", "values": [{"name": "1", "value": "1-55860-410-3"}]}, {"name": "ISBN", "values": [{"name": "1", "value": "0-201-39828-1"}]}], "id": 22}, {"title": "External links", "paragraphs": "{{Sister project links\n|commons=Category:Assembly languages\n|wikt=assembly language\n|v=assembly language\n|b=Subject:Assembly languages\n|q=no|s=no}}\n*{{DMOZ|Computers/Programming/Languages/Assembly/}}\n* [http://www.int80h.org/ Unix Assembly Language Programming]\n* [http://asm.sourceforge.net/ Linux Assembly]\n* [http://c2.com/cgi/wiki?LearningAssemblyLanguage PPR: Learning Assembly Language]\n* [http://www.nasm.us/ NASM \u2013 The Netwide Assembler (a popular assembly language)]\n* [http://www.azillionmonkeys.com/qed/asmexample.html Assembly Language Programming Examples]\n* [https://web.archive.org/web/20051125010505/http://grc.com/smgassembly.htm Authoring Windows Applications In Assembly Language]\n* [http://mark.masmcode.com/ Assembly Optimization Tips] by Mark Larson \n* [http://www.plantation-productions.com/Webster/www.artofasm.com/Windows/HTML/AoATOC.html The Art of Assembly Language ] by [[Randall Hyde]]\n* [https://wenku.baidu.com/view/85451cec4afe04a1b071de0f.html The table for assembly language to machine code]\n{{Programming language}}\n{{Programming languages}}\n{{Embedded systems}}\n{{Authority control}}\n\n{{DEFAULTSORT:Assembly Language}}\n[[Category:1949 software]]\n[[Category:Assembly languages|*Assembly language]]\n[[Category:Computer-related introductions in 1949]]\n[[Category:Embedded systems]]\n[[Category:Low-level programming languages]]\n[[Category:Programming language implementation]]\n[[Category:Programming languages created in 1949]]", "attributes": [{"name": "Sister project links\n", "values": [{"name": "commons", "value": "Category:Assembly languages"}, {"name": "wikt", "value": "assembly language"}, {"name": "v", "value": "assembly language"}, {"name": "b", "value": "Subject:Assembly languages"}, {"name": "q", "value": "no"}, {"name": "s", "value": "no"}]}, {"name": "DMOZ", "values": [{"name": "1", "value": "Computers/Programming/Languages/Assembly/"}]}], "id": 23}]}