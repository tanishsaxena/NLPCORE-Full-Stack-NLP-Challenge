{"title": "Kolmogorov complexity", "authors": ["Frap"], "time_published": "2019-12-20T09:48:32Z", "sections": [{"title": "", "paragraphs": "{{distinguish|Descriptive complexity theory}}\n{{short description|Measure for an object, of the length of the shortest computer program that produces the object as output}}\n[[Image:Mandelpart2 red.png|right|thumb|upright=1.4|This image illustrates part of the [[Mandelbrot set]] [[fractal]]. Simply storing the 24-bit color of each pixel in this image would require 1.62 million bytes, but a small computer program can reproduce these 1.62 million bytes using the definition of the Mandelbrot set and the coordinates of the corners of the image. Thus, the Kolmogorov complexity of the raw file encoding this bitmap is much less than 1.62 million bytes in any pragmatic model of computation.]]\n\nIn [[algorithmic information theory]] (a subfield of [[computer science]] and [[mathematics]]), the '''Kolmogorov complexity''' of an object, such as a piece of text, is the length of the shortest [[computer program]] (in a predetermined [[programming language]]) that produces the object as output. It is a measure of the [[computation]]al resources needed to specify the object, and is also known as '''algorithmic complexity''', '''Solomonoff\u2013Kolmogorov\u2013[[Gregory Chaitin|Chaitin]] complexity''', '''program-size complexity''', '''descriptive complexity''', or '''algorithmic entropy'''. It is named after [[Andrey Kolmogorov]], who first published on the subject in 1963.<ref>{{cite journal|authorlink=Andrey Kolmogorov|first=Andrey|last=Kolmogorov|year=1963|title=On Tables of Random Numbers| journal=Sankhy\u0101 Ser. A.|volume=25|pages=369\u2013375|mr=178484}}</ref><ref>{{cite journal|authorlink=Andrey Kolmogorov|first=Andrey|last=Kolmogorov|year=1998|title=On Tables of Random Numbers| journal=Theoretical Computer Science|volume=207|issue=2|pages=387\u2013395|doi=10.1016/S0304-3975(98)00075-9 |mr=1643414}}</ref>\n\nThe notion of Kolmogorov complexity can be used to state and [[Proof of impossibility|prove impossibility]] results akin to [[Cantor's diagonal argument]], [[G\u00f6del's incompleteness theorem]], and [[halting problem|Turing's halting problem]].\nIn particular, for almost all objects, it is not possible to compute even a [[lower bound]] for its Kolmogorov complexity ([[#Chaitin's incompleteness theorem|Chaitin 1964]]), let alone its exact value.\n\n", "attributes": [{"name": "distinguish", "values": [{"name": "1", "value": "Descriptive complexity theory"}]}, {"name": "short description", "values": [{"name": "1", "value": "Measure for an object, of the length of the shortest computer program that produces the object as output"}]}, {"name": "cite journal", "values": [{"name": "authorlink", "value": "Andrey Kolmogorov"}, {"name": "first", "value": "Andrey"}, {"name": "last", "value": "Kolmogorov"}, {"name": "year", "value": "1963"}, {"name": "title", "value": "On Tables of Random Numbers"}, {"name": "journal", "value": "Sankhy\u0101 Ser. A."}, {"name": "volume", "value": "25"}, {"name": "pages", "value": "369\u2013375"}, {"name": "mr", "value": "178484"}]}, {"name": "cite journal", "values": [{"name": "authorlink", "value": "Andrey Kolmogorov"}, {"name": "first", "value": "Andrey"}, {"name": "last", "value": "Kolmogorov"}, {"name": "year", "value": "1998"}, {"name": "title", "value": "On Tables of Random Numbers"}, {"name": "journal", "value": "Theoretical Computer Science"}, {"name": "volume", "value": "207"}, {"name": "issue", "value": "2"}, {"name": "pages", "value": "387\u2013395"}, {"name": "doi", "value": "10.1016/S0304-3975(98)00075-9"}, {"name": "mr", "value": "1643414"}]}], "id": 0}, {"title": "Definition", "paragraphs": "Consider the following two [[string (computer science)|strings]] of 32 lowercase letters and digits:\n\n:  <code>abababababababababababababababab</code> , and\n:  <code>4c1j5b2p0cv4w1x8rx2y39umgw5q85s7</code>\n\nThe first string has a short English-language description, namely \"<code>write ab 16 times</code>\", which consists of '''17''' characters. The second one has no obvious simple description (using the same character set) other than writing down the string itself, i.e., \"<code>write 4c1j5b2p0cv4w1x8rx2y39umgw5q85s7</code>\" which has '''38''' characters. Hence the operation of writing the first string can be said to have \"less complexity\" than writing the second.\n\nMore formally, the [[complexity]] of a string is the length of the shortest possible description of the string in some fixed [[Turing complete|universal]] description language (the sensitivity of complexity relative to the choice of description language is discussed below). It can be shown that the Kolmogorov complexity of any string cannot be more than a few bytes larger than the length of the string itself. Strings like the ''abab'' example above, whose Kolmogorov complexity is small relative to the string's size, are not considered to be complex.\n\nThe Kolmogorov complexity can be defined for any mathematical object, but for simplicity the scope of this article is restricted to strings. We must first specify a description language for strings.  Such a description language can be based on any computer programming language, such as [[Lisp programming language|Lisp]], [[Pascal (programming language)|Pascal]], or [[Java (programming language)|Java]].  If '''P''' is a program which outputs a string ''x'', then '''P''' is a description of ''x''. The length of the description is just the length of '''P''' as a character string, multiplied by the number of bits in a character (e.g., 7 for [[ASCII]]).\n\nWe could, alternatively, choose an encoding for [[Turing machine]]s, where an ''encoding'' is a function which associates to each Turing Machine '''M''' a bitstring <'''M'''>. If '''M''' is a Turing Machine which, on input ''w'', outputs string ''x'', then the concatenated string <'''M'''> ''w'' is a description of ''x''. For theoretical analysis, this approach is more suited for constructing detailed formal proofs and is generally preferred in the research literature. In this article, an informal approach is discussed.\n\nAny string ''s'' has at least one description. For example, the second string above is output by the program:\n\n '''function''' GenerateString1()\n     '''return''' \"4c1j5b2p0cv4w1x8rx2y39umgw5q85s7\"\n\nwhereas the first string is output by the (much shorter) pseudo-code:\n\n '''function''' GenerateString2()\n     '''return''' \"ab\" \u00d7 16\n\nIf a description ''d''(''s'') of a string ''s'' is of minimal length (i.e., using the fewest bits), it is called a '''minimal description''' of ''s'', and the length of ''d''(''s'') (i.e. the number of bits in the minimal description) is the '''Kolmogorov complexity''' of ''s'', written ''K''(''s''). Symbolically,\n\n:''K''(''s'') = |''d''(''s'')|.\n\nThe length of the shortest description will depend on the choice of description language; but the effect of changing languages is bounded (a result called the ''invariance theorem'').\n\n", "attributes": [], "id": 1}, {"title": "Invariance theorem", "paragraphs": "\n===Informal treatment===\nThere are some description languages which are optimal, in the following sense: given any description of an object in a description language, said description may be used in the optimal description language with a constant overhead. The constant depends only on the languages involved, not on the description of the object, nor the object being described.\n\nHere is an example of an optimal description language. A description will have two parts:\n\n* The first part describes another description language.\n* The second part is a description of the object in that language.\n\nIn more technical terms, the first part of a description is a computer program, with the second part being the input to that computer program which produces the object as output.\n\n'''The invariance theorem follows:''' Given any description language ''L'', the optimal description language is at least as efficient as ''L'', with some constant overhead.\n\n'''Proof:''' Any description ''D'' in ''L'' can be converted into a description in the optimal language by first describing ''L'' as a computer program ''P'' (part 1), and then using the original description ''D'' as input to that program (part 2). The\ntotal length of this new description ''D&prime;'' is (approximately):\n\n:|''D&prime;''| = |''P''| + |''D''|\n\nThe length of ''P'' is a constant that doesn't depend on ''D''. So, there is at most a constant overhead, regardless of the object described. Therefore, the optimal language is universal [[up to]] this additive constant.\n\n===A more formal treatment===\n'''Theorem''': If ''K''<sub>1</sub> and ''K''<sub>2</sub> are the complexity functions relative to [[Turing complete]] description languages ''L''<sub>1</sub> and ''L''<sub>2</sub>, then there is a constant ''c''&nbsp;\u2013 which depends only on the languages ''L''<sub>1</sub> and ''L''<sub>2</sub> chosen&nbsp;\u2013 such that\n\n:\u2200''s''.  \u2212''c'' \u2264 ''K''<sub>1</sub>(''s'') \u2212 ''K''<sub>2</sub>(''s'') \u2264 ''c''.\n\n'''Proof''': By symmetry, it suffices to prove that there is some constant ''c'' such that for all strings ''s''\n\n:''K''<sub>1</sub>(''s'') \u2264 ''K''<sub>2</sub>(''s'') + ''c''.\n\nNow, suppose there is a program in the language ''L''<sub>1</sub> which acts as an [[interpreter (computing)|interpreter]] for ''L''<sub>2</sub>:\n\n '''function''' InterpretLanguage('''string''' ''p'')\n\nwhere ''p'' is a program in ''L''<sub>2</sub>. The interpreter is characterized by the following property:\n\n: Running <code>InterpretLanguage</code> on input ''p'' returns the result of running ''p''.\n\nThus, if '''P''' is a program in ''L''<sub>2</sub> which is a minimal description of ''s'', then <code>InterpretLanguage</code>('''P''') returns the string ''s''. The length of this description of ''s'' is the sum of\n\n# The length of the program <code>InterpretLanguage</code>, which we can take to be the constant ''c''.\n# The length of '''P''' which by definition is ''K''<sub>2</sub>(''s'').\n\nThis proves the desired upper bound.\n\n", "attributes": [], "id": 2}, {"title": "Informal treatment", "paragraphs": "There are some description languages which are optimal, in the following sense: given any description of an object in a description language, said description may be used in the optimal description language with a constant overhead. The constant depends only on the languages involved, not on the description of the object, nor the object being described.\n\nHere is an example of an optimal description language. A description will have two parts:\n\n* The first part describes another description language.\n* The second part is a description of the object in that language.\n\nIn more technical terms, the first part of a description is a computer program, with the second part being the input to that computer program which produces the object as output.\n\n'''The invariance theorem follows:''' Given any description language ''L'', the optimal description language is at least as efficient as ''L'', with some constant overhead.\n\n'''Proof:''' Any description ''D'' in ''L'' can be converted into a description in the optimal language by first describing ''L'' as a computer program ''P'' (part 1), and then using the original description ''D'' as input to that program (part 2). The\ntotal length of this new description ''D&prime;'' is (approximately):\n\n:|''D&prime;''| = |''P''| + |''D''|\n\nThe length of ''P'' is a constant that doesn't depend on ''D''. So, there is at most a constant overhead, regardless of the object described. Therefore, the optimal language is universal [[up to]] this additive constant.\n\n", "attributes": [], "id": 3}, {"title": "A more formal treatment", "paragraphs": "'''Theorem''': If ''K''<sub>1</sub> and ''K''<sub>2</sub> are the complexity functions relative to [[Turing complete]] description languages ''L''<sub>1</sub> and ''L''<sub>2</sub>, then there is a constant ''c''&nbsp;\u2013 which depends only on the languages ''L''<sub>1</sub> and ''L''<sub>2</sub> chosen&nbsp;\u2013 such that\n\n:\u2200''s''.  \u2212''c'' \u2264 ''K''<sub>1</sub>(''s'') \u2212 ''K''<sub>2</sub>(''s'') \u2264 ''c''.\n\n'''Proof''': By symmetry, it suffices to prove that there is some constant ''c'' such that for all strings ''s''\n\n:''K''<sub>1</sub>(''s'') \u2264 ''K''<sub>2</sub>(''s'') + ''c''.\n\nNow, suppose there is a program in the language ''L''<sub>1</sub> which acts as an [[interpreter (computing)|interpreter]] for ''L''<sub>2</sub>:\n\n '''function''' InterpretLanguage('''string''' ''p'')\n\nwhere ''p'' is a program in ''L''<sub>2</sub>. The interpreter is characterized by the following property:\n\n: Running <code>InterpretLanguage</code> on input ''p'' returns the result of running ''p''.\n\nThus, if '''P''' is a program in ''L''<sub>2</sub> which is a minimal description of ''s'', then <code>InterpretLanguage</code>('''P''') returns the string ''s''. The length of this description of ''s'' is the sum of\n\n# The length of the program <code>InterpretLanguage</code>, which we can take to be the constant ''c''.\n# The length of '''P''' which by definition is ''K''<sub>2</sub>(''s'').\n\nThis proves the desired upper bound.\n\n", "attributes": [], "id": 4}, {"title": "History and context", "paragraphs": "[[Algorithmic information theory]] is the area of computer science that studies Kolmogorov complexity and other complexity measures on strings (or other [[data structure]]s).\n\nThe concept and theory of Kolmogorov Complexity is based on a crucial theorem first discovered by [[Ray Solomonoff]], who published it in 1960, describing it in \"A Preliminary Report on a General Theory of Inductive Inference\"<ref>{{cite journal |authorlink=Ray Solomonoff | last=Solomonoff |first= Ray | url=http://world.std.com/~rjs/rayfeb60.pdf | title=A Preliminary Report on a General Theory of Inductive Inference | journal= Report V-131 | date= February 4, 1960 }} [http://world.std.com/~rjs/z138.pdf revision], Nov., 1960.</ref> as part of his invention of [[algorithmic probability]]. He gave a more complete description in his 1964 publications, \"A Formal Theory of Inductive Inference,\" Part 1 and Part 2 in ''Information and Control''.<ref>{{cite journal\n| doi=10.1016/S0019-9958(64)90223-2\n| last=Solomonoff\n| first= Ray\n| title=A Formal Theory of Inductive Inference Part I\n| journal = Information and Control\n| url=http://world.std.com/~rjs/1964pt1.pdf\n| volume=7\n| issue= 1\n| pages= 1\u201322\n| date=March 1964\n}}</ref><ref>{{cite journal\n| doi=10.1016/S0019-9958(64)90131-7\n| last=Solomonoff\n|first= Ray\n| title=A Formal Theory of Inductive Inference Part II\n| journal = Information and Control\n| url=http://world.std.com/~rjs/1964pt2.pdf\n|volume=7\n|issue= 2\n|pages= 224\u2013254\n|date=June 1964\n}}</ref>\n\nAndrey Kolmogorov later [[multiple discovery|independently published]] this theorem in ''Problems Inform. Transmission''<ref>{{cite journal|volume=1 |issue=1 |year=1965 |pages=1\u20137 |title=Three Approaches to the Quantitative Definition of Information |url=http://www.ece.umd.edu/~abarg/ppi/contents/1-65-abstracts.html#1-65.2 |journal=Problems Inform. Transmission |first=A.N. |last=Kolmogorov |url-status=dead |archiveurl=https://web.archive.org/web/20110928032821/http://www.ece.umd.edu/~abarg/ppi/contents/1-65-abstracts.html |archivedate=September 28, 2011 }}</ref> in 1965. Gregory Chaitin also presents this theorem in ''J. ACM''&nbsp;\u2013 Chaitin's paper was submitted October 1966 and revised in December 1968, and cites both Solomonoff's and Kolmogorov's papers.<ref>{{cite journal | last1 = Chaitin | first1 = Gregory J. | title = On the Simplicity and Speed of Programs for Computing Infinite Sets of Natural Numbers| url=http://www.cs.auckland.ac.nz/~chaitin/acm69b.pdf| journal = Journal of the ACM | volume = 16 | pages = 407\u2013422| year = 1969 | doi = 10.1145/321526.321530 | issue = 3| citeseerx = 10.1.1.15.3821 }}</ref>\n\nThe theorem says that, among algorithms that decode strings from their descriptions (codes), there exists an optimal one. This algorithm, for all strings, allows codes as short as allowed by any other algorithm up to an additive constant that depends on the algorithms, but not on the strings themselves. Solomonoff used this algorithm and the code lengths it allows to define a \"universal probability\" of a string on which inductive inference of the subsequent digits of the string can be based. Kolmogorov used this theorem to define several functions of strings, including complexity, randomness, and information.\n\nWhen Kolmogorov became aware of Solomonoff's work, he acknowledged Solomonoff's priority.<ref>{{cite journal | last1=Kolmogorov | first1=A. | title=Logical basis for information theory and probability theory | journal=IEEE Transactions on Information Theory | volume=14|issue=5 | pages=662\u2013664 | year=1968 | doi =10.1109/TIT.1968.1054210 }}</ref> For several years, Solomonoff's work was better known in the Soviet Union than in the Western World. The general consensus in the scientific community, however, was to associate this type of complexity with Kolmogorov, who was concerned with randomness of a sequence, while Algorithmic Probability became associated with Solomonoff, who focused on prediction using his invention of the universal prior probability distribution. The broader area encompassing descriptional complexity and probability is often called Kolmogorov complexity. The computer scientist Ming Li considers this an example of the [[Matthew effect (sociology)|Matthew effect]]: \"\u2026to everyone who has more will be given\u2026\"<ref>{{Cite book |doi=10.1007/978-0-387-49820-1_1 |chapter=Preliminaries |title=An Introduction to Kolmogorov Complexity and its Applications |pages=1\u201399 |series=Texts in Computer Science |year=2008 |last1=Li |first1=Ming |last2=Vit\u00e1nyi |first2=Paul |isbn=978-0-387-33998-6 }}</ref>\n\nThere are several other variants of Kolmogorov complexity or algorithmic information. The most widely used one is based on [[self-delimiting program]]s, and is mainly due to [[Leonid Levin]] (1974).\n\nAn axiomatic approach to Kolmogorov complexity based on [[Blum axioms]] (Blum 1967) was introduced by Mark Burgin in the paper presented for publication by Andrey Kolmogorov.<ref name=Burgin1982>Burgin, M. (1982), \"Generalized Kolmogorov complexity and duality in theory of computations\", ''Notices of the Russian Academy of Sciences'', v.25, No. 3, pp.&nbsp;19\u201323.</ref>\n\n", "attributes": [{"name": "cite journal ", "values": [{"name": "authorlink", "value": "Ray Solomonoff"}, {"name": "last", "value": "Solomonoff"}, {"name": "first", "value": "Ray"}, {"name": "url", "value": "http://world.std.com/~rjs/rayfeb60.pdf"}, {"name": "title", "value": "A Preliminary Report on a General Theory of Inductive Inference"}, {"name": "journal", "value": "Report V-131"}, {"name": "date", "value": "February 4, 1960"}]}, {"name": "cite journal\n", "values": [{"name": "doi", "value": "10.1016/S0019-9958(64)90223-2"}, {"name": "last", "value": "Solomonoff"}, {"name": "first", "value": "Ray"}, {"name": "title", "value": "A Formal Theory of Inductive Inference Part I"}, {"name": "journal", "value": "Information and Control"}, {"name": "url", "value": "http://world.std.com/~rjs/1964pt1.pdf"}, {"name": "volume", "value": "7"}, {"name": "issue", "value": "1"}, {"name": "pages", "value": "1\u201322"}, {"name": "date", "value": "March 1964"}]}, {"name": "cite journal\n", "values": [{"name": "doi", "value": "10.1016/S0019-9958(64)90131-7"}, {"name": "last", "value": "Solomonoff"}, {"name": "first", "value": "Ray"}, {"name": "title", "value": "A Formal Theory of Inductive Inference Part II"}, {"name": "journal", "value": "Information and Control"}, {"name": "url", "value": "http://world.std.com/~rjs/1964pt2.pdf"}, {"name": "volume", "value": "7"}, {"name": "issue", "value": "2"}, {"name": "pages", "value": "224\u2013254"}, {"name": "date", "value": "June 1964"}]}, {"name": "cite journal", "values": [{"name": "volume", "value": "1"}, {"name": "issue", "value": "1"}, {"name": "year", "value": "1965"}, {"name": "pages", "value": "1\u20137"}, {"name": "title", "value": "Three Approaches to the Quantitative Definition of Information"}, {"name": "url", "value": "http://www.ece.umd.edu/~abarg/ppi/contents/1-65-abstracts.html#1-65.2"}, {"name": "journal", "value": "Problems Inform. Transmission"}, {"name": "first", "value": "A.N."}, {"name": "last", "value": "Kolmogorov"}, {"name": "url-status", "value": "dead"}, {"name": "archiveurl", "value": "https://web.archive.org/web/20110928032821/http://www.ece.umd.edu/~abarg/ppi/contents/1-65-abstracts.html"}, {"name": "archivedate", "value": "September 28, 2011"}]}, {"name": "cite journal ", "values": [{"name": "last1", "value": "Chaitin"}, {"name": "first1", "value": "Gregory J."}, {"name": "title", "value": "On the Simplicity and Speed of Programs for Computing Infinite Sets of Natural Numbers"}, {"name": "url", "value": "http://www.cs.auckland.ac.nz/~chaitin/acm69b.pdf"}, {"name": "journal", "value": "Journal of the ACM"}, {"name": "volume", "value": "16"}, {"name": "pages", "value": "407\u2013422"}, {"name": "year", "value": "1969"}, {"name": "doi", "value": "10.1145/321526.321530"}, {"name": "issue", "value": "3"}, {"name": "citeseerx", "value": "10.1.1.15.3821"}]}, {"name": "cite journal ", "values": [{"name": "last1", "value": "Kolmogorov"}, {"name": "first1", "value": "A."}, {"name": "title", "value": "Logical basis for information theory and probability theory"}, {"name": "journal", "value": "IEEE Transactions on Information Theory"}, {"name": "volume", "value": "14"}, {"name": "issue", "value": "5"}, {"name": "pages", "value": "662\u2013664"}, {"name": "year", "value": "1968"}, {"name": "doi", "value": "10.1109/TIT.1968.1054210"}]}, {"name": "Cite book ", "values": [{"name": "doi", "value": "10.1007/978-0-387-49820-1_1"}, {"name": "chapter", "value": "Preliminaries"}, {"name": "title", "value": "An Introduction to Kolmogorov Complexity and its Applications"}, {"name": "pages", "value": "1\u201399"}, {"name": "series", "value": "Texts in Computer Science"}, {"name": "year", "value": "2008"}, {"name": "last1", "value": "Li"}, {"name": "first1", "value": "Ming"}, {"name": "last2", "value": "Vit\u00e1nyi"}, {"name": "first2", "value": "Paul"}, {"name": "isbn", "value": "978-0-387-33998-6"}]}], "id": 5}, {"title": "Basic results", "paragraphs": "In the following discussion, let ''K''(''s'') be the complexity of the string ''s''.\n\nIt is not hard to see that the minimal description of a string cannot be too much larger than the string itself&nbsp;\u2014 the program <code>GenerateFixedString</code> above that outputs ''s'' is a fixed amount larger than ''s''.\n\n'''Theorem''': There is a constant ''c'' such that\n\n:\u2200''s''. ''K''(''s'') \u2264 |''s''| + ''c''.\n\n===Uncomputability of Kolmogorov complexity===\n\n'''Theorem''': There exist strings of arbitrarily large Kolmogorov complexity. Formally: for each ''n'' \u2208 \u2115, there is a string ''s'' with ''K''(''s'') \u2265 ''n''.<ref group=\"note\">However, an ''s'' with ''K''(''s'') = ''n'' need not exist for every ''n''. For example, if ''n'' is not a multiple of 7 bits, no [[ASCII]] program can have a length of exactly ''n'' bits.</ref>\n\n'''Proof:''' Otherwise all of the infinitely many possible finite strings could be generated by the finitely many<ref group=\"note\">There are 1 + 2 + 2<sup>2</sup> + 2<sup>3</sup> + ... + 2<sup>''n''</sup> = 2<sup>''n''+1</sup> \u2212 1 different program texts of length up to ''n'' bits; cf. [[geometric series]]. If program lengths are to be multiples of 7 bits, even fewer program texts exist.</ref> programs with a complexity below ''n'' bits.\n\n'''Theorem''':  ''K'' is not a [[computable function]]. In other words, there is no program which takes a string ''s'' as input and produces the integer ''K''(''s'') as output.\n\nThe following [[indirect proof|indirect '''proof''']] uses a simple [[Pascal (programming language)|Pascal]]-like language to denote programs; for sake of proof simplicity assume its description (i.e. an [[interpreter (computing)|interpreter]]) to have a length of {{val|1400000}} bits.\nAssume for contradiction there is a program\n\n '''function''' KolmogorovComplexity('''string''' s)\n\nwhich takes as input a string ''s'' and returns ''K''(''s''); for sake of proof simplicity, assume the program's length to be {{val|7000000000}} bits.\nNow, consider the following program of length {{val|1288}} bits:\n\n '''function''' GenerateComplexString()\n     '''for''' i = 1 '''to''' infinity:\n         '''for each''' string s '''of''' length exactly i\n             '''if''' KolmogorovComplexity(s) \u2265 8000000000\n                 '''return''' s\n\nUsing <code>KolmogorovComplexity</code> as a subroutine, the program tries every string, starting with the shortest, until it returns a string with Kolmogorov complexity at least {{val|8000000000}} bits,<ref group=\"note\">By the previous theorem, such a string exists, hence the <code>for</code> loop will eventually terminate.</ref> i.e. a string that cannot be produced by any program shorter than {{val|8000000000}} bits. However, the overall length of the above program that produced ''s'' is only {{val|7001401288}} bits,<ref group=note>including the language interpreter and the subroutine code for <code>KolmogorovComplexity</code></ref> which is a contradiction. (If the code of <code>KolmogorovComplexity</code> is shorter, the contradiction remains. If it is longer, the constant used in <code>GenerateComplexString</code> can always be changed appropriately.)<ref group=note>If <code>KolmogorovComplexity</code> has length ''n'' bits, the constant ''m'' used in <code>GenerateComplexString</code> needs to be adapted to satisfy {{nobreak|''n'' + {{val|1400000}} + {{val|1218}} + 7\u00b7log<sub>10</sub>(''m'') < ''m''}}, which is always possible since ''m'' grows faster than log<sub>10</sub>(''m'').</ref>\n\nThe above proof uses a contradiction similar to that of the [[Berry paradox]]: \"<sub>{{color|#8080ff|1}}</sub>The <sub>{{color|#8080ff|2}}</sub>smallest <sub>{{color|#8080ff|3}}</sub>positive <sub>{{color|#8080ff|4}}</sub>integer <sub>{{color|#8080ff|5}}</sub>that <sub>{{color|#8080ff|6}}</sub>cannot <sub>{{color|#8080ff|7}}</sub>be <sub>{{color|#8080ff|8}}</sub>defined <sub>{{color|#8080ff|9}}</sub>in <sub>{{color|#8080ff|10}}</sub>fewer <sub>{{color|#8080ff|11}}</sub>than <sub>{{color|#8080ff|12}}</sub>twenty <sub>{{color|#8080ff|13}}</sub>English <sub>{{color|#8080ff|14}}</sub>words\". It is also possible to show the non-computability of ''K'' by reduction from the non-computability of the halting problem ''H'', since ''K'' and ''H'' are [[turing degree#Turing equivalence|Turing-equivalent]].<ref>Stated without proof in: [http://www.daimi.au.dk/~bromille/DC05/Kolmogorov.pdf \"Course notes for Data Compression - Kolmogorov complexity\"], 2005, P. B. Miltersen, p.7</ref>\n\nThere is a corollary, humorously called the \"[[full employment theorem]]\" in the programming language community, stating that there is no perfect size-optimizing compiler.\n\n==== A naive attempt at a program to compute ''K'' ====\n\nAt first glance it might seem trivial to write a program which can compute ''K''(''s'') for any ''s'' (thus disproving the above theorem), such as the following:\n\n '''function''' KolmogorovComplexity('''string''' s)\n     '''for''' i = 1 '''to''' infinity:\n         '''for each''' string p '''of''' length exactly i\n             '''if''' isValidProgram(p) '''and''' evaluate(p) == s\n                 '''return''' i\n\nThis program iterates through all possible programs (by iterating through all possible strings and only considering those which are valid programs), starting with the shortest. Each program is executed to find the result produced by that program, comparing it to the input ''s''. If the result matches the length of the program is returned.\n\nHowever this will not work because some of the programs ''p'' tested will not terminate, e.g. if they contain infinite loops. There is no way to avoid all of these programs by testing them in some way before executing them due to the non-computability of the halting problem.\n\n===Chain rule for Kolmogorov complexity===\n{{Main| Chain rule for Kolmogorov complexity}}\nThe chain rule<ref>{{cite news\n  | first = A.\n  | last = Zvonkin\n  |author2=L. Levin\n  | title = The complexity of finite objects and the development of the concepts of information and randomness by means of the theory of algorithms.\n  | journal = Russian Mathematical Surveys\n  | volume = 25\n  | number = 6\n  | pages = 83\u2013124\n  | year = 1970\n  | url = http://alexander.shen.free.fr/library/Zvonkin_Levin_70.pdf}}</ref> for Kolmogorov complexity states that\n\n:''K''(''X'',''Y'') \u2264 ''K''(''X'') + ''K''(''Y''|''X'') + ''O''(log(''K''(''X'',''Y''))).\n\nIt states that the shortest program that reproduces ''X'' and ''Y'' is [[Big-O notation|no more]] than a logarithmic term larger than a program to reproduce ''X'' and a program to reproduce ''Y'' given ''X''. Using this statement, one can define [[Mutual information#Absolute mutual information|an analogue of mutual information for Kolmogorov complexity]].\n\n", "attributes": [{"name": "val", "values": [{"name": "1", "value": "1400000"}]}, {"name": "val", "values": [{"name": "1", "value": "7000000000"}]}, {"name": "val", "values": [{"name": "1", "value": "1288"}]}, {"name": "val", "values": [{"name": "1", "value": "8000000000"}]}, {"name": "val", "values": [{"name": "1", "value": "8000000000"}]}, {"name": "val", "values": [{"name": "1", "value": "7001401288"}]}, {"name": "nobreak", "values": [{"name": "1", "value": "''n'' + {{val|1400000}} + {{val|1218}} + 7\u00b7log<sub>10</sub>(''m'') < ''m''"}]}, {"name": "val", "values": [{"name": "1", "value": "1400000"}]}, {"name": "val", "values": [{"name": "1", "value": "1218"}]}, {"name": "color", "values": [{"name": "1", "value": "#8080ff"}, {"name": "2", "value": "1"}]}, {"name": "color", "values": [{"name": "1", "value": "#8080ff"}, {"name": "2", "value": "2"}]}, {"name": "color", "values": [{"name": "1", "value": "#8080ff"}, {"name": "2", "value": "3"}]}, {"name": "color", "values": [{"name": "1", "value": "#8080ff"}, {"name": "2", "value": "4"}]}, {"name": "color", "values": [{"name": "1", "value": "#8080ff"}, {"name": "2", "value": "5"}]}, {"name": "color", "values": [{"name": "1", "value": "#8080ff"}, {"name": "2", "value": "6"}]}, {"name": "color", "values": [{"name": "1", "value": "#8080ff"}, {"name": "2", "value": "7"}]}, {"name": "color", "values": [{"name": "1", "value": "#8080ff"}, {"name": "2", "value": "8"}]}, {"name": "color", "values": [{"name": "1", "value": "#8080ff"}, {"name": "2", "value": "9"}]}, {"name": "color", "values": [{"name": "1", "value": "#8080ff"}, {"name": "2", "value": "10"}]}, {"name": "color", "values": [{"name": "1", "value": "#8080ff"}, {"name": "2", "value": "11"}]}, {"name": "color", "values": [{"name": "1", "value": "#8080ff"}, {"name": "2", "value": "12"}]}, {"name": "color", "values": [{"name": "1", "value": "#8080ff"}, {"name": "2", "value": "13"}]}, {"name": "color", "values": [{"name": "1", "value": "#8080ff"}, {"name": "2", "value": "14"}]}, {"name": "Main", "values": [{"name": "1", "value": "Chain rule for Kolmogorov complexity"}]}, {"name": "cite news\n  ", "values": [{"name": "first", "value": "A."}, {"name": "last", "value": "Zvonkin"}, {"name": "author2", "value": "L. Levin"}, {"name": "title", "value": "The complexity of finite objects and the development of the concepts of information and randomness by means of the theory of algorithms."}, {"name": "journal", "value": "Russian Mathematical Surveys"}, {"name": "volume", "value": "25"}, {"name": "number", "value": "6"}, {"name": "pages", "value": "83\u2013124"}, {"name": "year", "value": "1970"}, {"name": "url", "value": "http://alexander.shen.free.fr/library/Zvonkin_Levin_70.pdf"}]}], "id": 6}, {"title": "Uncomputability of Kolmogorov complexity", "paragraphs": "\n'''Theorem''': There exist strings of arbitrarily large Kolmogorov complexity. Formally: for each ''n'' \u2208 \u2115, there is a string ''s'' with ''K''(''s'') \u2265 ''n''.<ref group=\"note\">However, an ''s'' with ''K''(''s'') = ''n'' need not exist for every ''n''. For example, if ''n'' is not a multiple of 7 bits, no [[ASCII]] program can have a length of exactly ''n'' bits.</ref>\n\n'''Proof:''' Otherwise all of the infinitely many possible finite strings could be generated by the finitely many<ref group=\"note\">There are 1 + 2 + 2<sup>2</sup> + 2<sup>3</sup> + ... + 2<sup>''n''</sup> = 2<sup>''n''+1</sup> \u2212 1 different program texts of length up to ''n'' bits; cf. [[geometric series]]. If program lengths are to be multiples of 7 bits, even fewer program texts exist.</ref> programs with a complexity below ''n'' bits.\n\n'''Theorem''':  ''K'' is not a [[computable function]]. In other words, there is no program which takes a string ''s'' as input and produces the integer ''K''(''s'') as output.\n\nThe following [[indirect proof|indirect '''proof''']] uses a simple [[Pascal (programming language)|Pascal]]-like language to denote programs; for sake of proof simplicity assume its description (i.e. an [[interpreter (computing)|interpreter]]) to have a length of {{val|1400000}} bits.\nAssume for contradiction there is a program\n\n '''function''' KolmogorovComplexity('''string''' s)\n\nwhich takes as input a string ''s'' and returns ''K''(''s''); for sake of proof simplicity, assume the program's length to be {{val|7000000000}} bits.\nNow, consider the following program of length {{val|1288}} bits:\n\n '''function''' GenerateComplexString()\n     '''for''' i = 1 '''to''' infinity:\n         '''for each''' string s '''of''' length exactly i\n             '''if''' KolmogorovComplexity(s) \u2265 8000000000\n                 '''return''' s\n\nUsing <code>KolmogorovComplexity</code> as a subroutine, the program tries every string, starting with the shortest, until it returns a string with Kolmogorov complexity at least {{val|8000000000}} bits,<ref group=\"note\">By the previous theorem, such a string exists, hence the <code>for</code> loop will eventually terminate.</ref> i.e. a string that cannot be produced by any program shorter than {{val|8000000000}} bits. However, the overall length of the above program that produced ''s'' is only {{val|7001401288}} bits,<ref group=note>including the language interpreter and the subroutine code for <code>KolmogorovComplexity</code></ref> which is a contradiction. (If the code of <code>KolmogorovComplexity</code> is shorter, the contradiction remains. If it is longer, the constant used in <code>GenerateComplexString</code> can always be changed appropriately.)<ref group=note>If <code>KolmogorovComplexity</code> has length ''n'' bits, the constant ''m'' used in <code>GenerateComplexString</code> needs to be adapted to satisfy {{nobreak|''n'' + {{val|1400000}} + {{val|1218}} + 7\u00b7log<sub>10</sub>(''m'') < ''m''}}, which is always possible since ''m'' grows faster than log<sub>10</sub>(''m'').</ref>\n\nThe above proof uses a contradiction similar to that of the [[Berry paradox]]: \"<sub>{{color|#8080ff|1}}</sub>The <sub>{{color|#8080ff|2}}</sub>smallest <sub>{{color|#8080ff|3}}</sub>positive <sub>{{color|#8080ff|4}}</sub>integer <sub>{{color|#8080ff|5}}</sub>that <sub>{{color|#8080ff|6}}</sub>cannot <sub>{{color|#8080ff|7}}</sub>be <sub>{{color|#8080ff|8}}</sub>defined <sub>{{color|#8080ff|9}}</sub>in <sub>{{color|#8080ff|10}}</sub>fewer <sub>{{color|#8080ff|11}}</sub>than <sub>{{color|#8080ff|12}}</sub>twenty <sub>{{color|#8080ff|13}}</sub>English <sub>{{color|#8080ff|14}}</sub>words\". It is also possible to show the non-computability of ''K'' by reduction from the non-computability of the halting problem ''H'', since ''K'' and ''H'' are [[turing degree#Turing equivalence|Turing-equivalent]].<ref>Stated without proof in: [http://www.daimi.au.dk/~bromille/DC05/Kolmogorov.pdf \"Course notes for Data Compression - Kolmogorov complexity\"], 2005, P. B. Miltersen, p.7</ref>\n\nThere is a corollary, humorously called the \"[[full employment theorem]]\" in the programming language community, stating that there is no perfect size-optimizing compiler.\n\n==== A naive attempt at a program to compute ''K'' ====\n\nAt first glance it might seem trivial to write a program which can compute ''K''(''s'') for any ''s'' (thus disproving the above theorem), such as the following:\n\n '''function''' KolmogorovComplexity('''string''' s)\n     '''for''' i = 1 '''to''' infinity:\n         '''for each''' string p '''of''' length exactly i\n             '''if''' isValidProgram(p) '''and''' evaluate(p) == s\n                 '''return''' i\n\nThis program iterates through all possible programs (by iterating through all possible strings and only considering those which are valid programs), starting with the shortest. Each program is executed to find the result produced by that program, comparing it to the input ''s''. If the result matches the length of the program is returned.\n\nHowever this will not work because some of the programs ''p'' tested will not terminate, e.g. if they contain infinite loops. There is no way to avoid all of these programs by testing them in some way before executing them due to the non-computability of the halting problem.\n\n", "attributes": [{"name": "val", "values": [{"name": "1", "value": "1400000"}]}, {"name": "val", "values": [{"name": "1", "value": "7000000000"}]}, {"name": "val", "values": [{"name": "1", "value": "1288"}]}, {"name": "val", "values": [{"name": "1", "value": "8000000000"}]}, {"name": "val", "values": [{"name": "1", "value": "8000000000"}]}, {"name": "val", "values": [{"name": "1", "value": "7001401288"}]}, {"name": "nobreak", "values": [{"name": "1", "value": "''n'' + {{val|1400000}} + {{val|1218}} + 7\u00b7log<sub>10</sub>(''m'') < ''m''"}]}, {"name": "val", "values": [{"name": "1", "value": "1400000"}]}, {"name": "val", "values": [{"name": "1", "value": "1218"}]}, {"name": "color", "values": [{"name": "1", "value": "#8080ff"}, {"name": "2", "value": "1"}]}, {"name": "color", "values": [{"name": "1", "value": "#8080ff"}, {"name": "2", "value": "2"}]}, {"name": "color", "values": [{"name": "1", "value": "#8080ff"}, {"name": "2", "value": "3"}]}, {"name": "color", "values": [{"name": "1", "value": "#8080ff"}, {"name": "2", "value": "4"}]}, {"name": "color", "values": [{"name": "1", "value": "#8080ff"}, {"name": "2", "value": "5"}]}, {"name": "color", "values": [{"name": "1", "value": "#8080ff"}, {"name": "2", "value": "6"}]}, {"name": "color", "values": [{"name": "1", "value": "#8080ff"}, {"name": "2", "value": "7"}]}, {"name": "color", "values": [{"name": "1", "value": "#8080ff"}, {"name": "2", "value": "8"}]}, {"name": "color", "values": [{"name": "1", "value": "#8080ff"}, {"name": "2", "value": "9"}]}, {"name": "color", "values": [{"name": "1", "value": "#8080ff"}, {"name": "2", "value": "10"}]}, {"name": "color", "values": [{"name": "1", "value": "#8080ff"}, {"name": "2", "value": "11"}]}, {"name": "color", "values": [{"name": "1", "value": "#8080ff"}, {"name": "2", "value": "12"}]}, {"name": "color", "values": [{"name": "1", "value": "#8080ff"}, {"name": "2", "value": "13"}]}, {"name": "color", "values": [{"name": "1", "value": "#8080ff"}, {"name": "2", "value": "14"}]}], "id": 7}, {"title": " A naive attempt at a program to compute ''K'' ", "paragraphs": "\nAt first glance it might seem trivial to write a program which can compute ''K''(''s'') for any ''s'' (thus disproving the above theorem), such as the following:\n\n '''function''' KolmogorovComplexity('''string''' s)\n     '''for''' i = 1 '''to''' infinity:\n         '''for each''' string p '''of''' length exactly i\n             '''if''' isValidProgram(p) '''and''' evaluate(p) == s\n                 '''return''' i\n\nThis program iterates through all possible programs (by iterating through all possible strings and only considering those which are valid programs), starting with the shortest. Each program is executed to find the result produced by that program, comparing it to the input ''s''. If the result matches the length of the program is returned.\n\nHowever this will not work because some of the programs ''p'' tested will not terminate, e.g. if they contain infinite loops. There is no way to avoid all of these programs by testing them in some way before executing them due to the non-computability of the halting problem.\n\n", "attributes": [], "id": 8}, {"title": "Chain rule for Kolmogorov complexity", "paragraphs": "{{Main| Chain rule for Kolmogorov complexity}}\nThe chain rule<ref>{{cite news\n  | first = A.\n  | last = Zvonkin\n  |author2=L. Levin\n  | title = The complexity of finite objects and the development of the concepts of information and randomness by means of the theory of algorithms.\n  | journal = Russian Mathematical Surveys\n  | volume = 25\n  | number = 6\n  | pages = 83\u2013124\n  | year = 1970\n  | url = http://alexander.shen.free.fr/library/Zvonkin_Levin_70.pdf}}</ref> for Kolmogorov complexity states that\n\n:''K''(''X'',''Y'') \u2264 ''K''(''X'') + ''K''(''Y''|''X'') + ''O''(log(''K''(''X'',''Y''))).\n\nIt states that the shortest program that reproduces ''X'' and ''Y'' is [[Big-O notation|no more]] than a logarithmic term larger than a program to reproduce ''X'' and a program to reproduce ''Y'' given ''X''. Using this statement, one can define [[Mutual information#Absolute mutual information|an analogue of mutual information for Kolmogorov complexity]].\n\n", "attributes": [{"name": "Main", "values": [{"name": "1", "value": "Chain rule for Kolmogorov complexity"}]}, {"name": "cite news\n  ", "values": [{"name": "first", "value": "A."}, {"name": "last", "value": "Zvonkin"}, {"name": "author2", "value": "L. Levin"}, {"name": "title", "value": "The complexity of finite objects and the development of the concepts of information and randomness by means of the theory of algorithms."}, {"name": "journal", "value": "Russian Mathematical Surveys"}, {"name": "volume", "value": "25"}, {"name": "number", "value": "6"}, {"name": "pages", "value": "83\u2013124"}, {"name": "year", "value": "1970"}, {"name": "url", "value": "http://alexander.shen.free.fr/library/Zvonkin_Levin_70.pdf"}]}], "id": 9}, {"title": "Compression", "paragraphs": "It is straightforward to compute upper bounds for ''K''(''s'')&nbsp;\u2013 simply [[data compression|compress]] the string ''s'' with some method, implement the corresponding decompressor in the chosen language, concatenate the decompressor to the compressed string, and measure the length of the resulting string&nbsp;\u2013 concretely, the size of a [[self-extracting archive]] in the given language.\n\nA string ''s'' is compressible by a number ''c'' if it has a description whose length does not exceed |''s''| \u2212 ''c'' bits. This is equivalent to saying that ''K''(''s'') \u2264 |''s''| \u2212 ''c''.  Otherwise, ''s'' is incompressible by ''c''. A string incompressible by 1 is said to be simply ''incompressible''&nbsp;\u2013 by the [[pigeonhole principle]], which applies because every compressed string maps to only one uncompressed string, [[incompressible string]]s must exist, since there are 2<sup>''n''</sup> bit strings of length ''n'', but only 2<sup>''n''</sup> \u2212 1 shorter strings, that is, strings of length less than ''n'', (i.e. with length 0, 1, ..., ''n&nbsp;\u2212&nbsp;1).<ref group=note>As there are {{nobr|1=''N''<sub>''L''</sub> = 2<sup>''L''</sup>}} strings of length ''L'', the number of strings of lengths {{nowrap|1=''L'' = 0, 1, \u2026, ''n'' \u2212 1}} is {{nobr|''N''<sub>0</sub> + ''N''<sub>1</sub> + \u2026 + ''N''<sub>''n''\u22121</sub>}} = {{nobr|2<sup>0</sup> + 2<sup>1</sup> + \u2026 + 2<sup>''n''\u22121</sup>}}, which is a finite [[geometric series]] with sum {{nobr|2<sup>0</sup> + 2<sup>1</sup> + \u2026 + 2<sup>''n''\u22121</sup>}} = {{nobr|1 = 2<sup>0</sup> \u00d7 (1 \u2212 2<sup>''n''</sup>) / (1 \u2212 2) = 2<sup>''n''</sup> \u2212 1}}</ref>\n\nFor the same reason, most strings are complex in the sense that they cannot be significantly compressed&nbsp;\u2013 their ''K''(''s'') is not much smaller than |''s''|, the length of ''s'' in bits. To make this precise, fix a value of ''n''. There are 2<sup>''n''</sup> bitstrings of length ''n''. The [[Uniform distribution (discrete)|uniform]] [[probability]] distribution on the space of these bitstrings assigns exactly equal weight 2<sup>\u2212''n''</sup> to each string of length ''n''.\n\n'''Theorem''': With the uniform probability distribution on the space of bitstrings of length ''n'', the probability that a string is incompressible by ''c'' is at least 1 \u2212 2<sup>\u2212''c''+1</sup> + 2<sup>\u2212''n''</sup>.\n\nTo prove the theorem, note that the number of descriptions of length not exceeding ''n'' \u2212 ''c'' is given by the geometric series:\n\n: 1 + 2 + 2<sup>2</sup> + \u2026 + 2<sup>''n'' \u2212 ''c''</sup> = 2<sup>''n''\u2212''c''+1</sup> \u2212 1.\n\nThere remain at least\n\n: 2<sup>''n''</sup> \u2212 2<sup>''n''\u2212''c''+1</sup> + 1\n\nbitstrings of length ''n'' that are incompressible by ''c''.  To determine the probability, divide by 2<sup>''n''</sup>.\n\n", "attributes": [{"name": "nobr", "values": [{"name": "1", "value": "''N''<sub>''L''</sub> = 2<sup>''L''</sup>"}]}, {"name": "nowrap", "values": [{"name": "1", "value": "''L'' = 0, 1, \u2026, ''n'' \u2212 1"}]}, {"name": "nobr", "values": [{"name": "1", "value": "''N''<sub>0</sub> + ''N''<sub>1</sub> + \u2026 + ''N''<sub>''n''\u22121</sub>"}]}, {"name": "nobr", "values": [{"name": "1", "value": "2<sup>0</sup> + 2<sup>1</sup> + \u2026 + 2<sup>''n''\u22121</sup>"}]}, {"name": "nobr", "values": [{"name": "1", "value": "2<sup>0</sup> + 2<sup>1</sup> + \u2026 + 2<sup>''n''\u22121</sup>"}]}, {"name": "nobr", "values": [{"name": "1", "value": "2<sup>0</sup> \u00d7 (1 \u2212 2<sup>''n''</sup>) / (1 \u2212 2) = 2<sup>''n''</sup> \u2212 1"}]}], "id": 10}, {"title": "Chaitin's incompleteness theorem", "paragraphs": "[[File:Kolmogorov complexity and computable lower bounds.gif|thumb|right|500px|Kolmogorov complexity {{color|#800000|''K''(''s'')}}, and two computable lower bound functions <code>{{color|#808000|prog1(s)}}</code>, <code>{{color|#008000|prog2(s)}}</code>. The horizontal axis ([[logarithmic scale]]) enumerates all [[string (computer science)|strings]] ''s'', ordered by length; the vertical axis ([[linear scale]]) measures Kolmogorov complexity in [[bit]]s. Most strings are incompressible, i.e. their Kolmogorov complexity exceeds their length by a constant amount. 17 compressible strings are shown in the picture, appearing as almost vertical slopes. Due to Chaitin's incompleteness theorem (1974), the output of any program computing a lower bound of the Kolmogorov complexity cannot exceed some fixed limit, which is independent of the input string ''s''.]]\nWe know that, in the set of all possible strings, most strings are complex in the sense that they cannot be described in any significantly \"compressed\" way. However, it turns out that the fact that a specific string is complex cannot be formally proven, if the complexity of the string is above a certain threshold. The precise formalization is as follows. First, fix a particular [[axiomatic system]] '''S''' for the [[natural number]]s. The axiomatic system has to be powerful enough so that, to certain assertions  '''A''' about complexity of strings, one can associate a formula '''F'''<sub>'''A'''</sub> in '''S'''. This association must have the following property:\n\nIf '''F'''<sub>'''A'''</sub> is provable from the axioms of '''S''', then the corresponding assertion '''A''' must be true. This \"formalization\" can be achieved, either by an artificial encoding such as a [[G\u00f6del numbering]], or by a formalization which more clearly respects the intended interpretation of '''S'''.\n\n'''Theorem''': There exists a constant ''L'' (which only depends on the particular axiomatic system and the choice of description language) such that there does not exist a string ''s'' for which the statement\n\n:''K''(''s'') \u2265  ''L'' (as formalized in '''S''')\n\ncan be proven within the axiomatic system '''S'''.\n\nBy the abundance of nearly incompressible strings, the vast majority of those statements must be true.\n\nThe proof of this result is modeled on a self-referential construction used in [[Berry's paradox]]. The proof is by contradiction. If the theorem were false, then\n\n:'''Assumption (X)''': For any integer ''n'' there exists a string ''s'' for which there is a proof in '''S''' of the formula \"''K''(''s'')&nbsp;\u2265&nbsp;''n''\" (which we assume can be formalized in '''S''').\n\nWe can find an effective enumeration of all the formal proofs in '''S''' by some procedure\n\n '''function''' NthProof('''int''' ''n'')\nwhich takes as input ''n'' and outputs some proof. This function enumerates all proofs. Some of these are proofs for formulas we do not care about here, since every possible proof in the language of '''S''' is produced for some ''n''. Some of these are complexity formulas of the form ''K''(''s'')&nbsp;\u2265&nbsp;''n'' where ''s'' and ''n'' are constants in the language of '''S'''. There is a program\n\n '''function''' NthProofProvesComplexityFormula('''int''' ''n'')\n\nwhich determines whether the ''n''th proof actually proves a complexity formula ''K''(''s'')&nbsp;\u2265&nbsp;''L''. The strings ''s'', and the integer ''L'' in turn, are computable by programs:\n\n '''function''' StringNthProof('''int''' ''n'')\n\n '''function''' ComplexityLowerBoundNthProof('''int''' ''n'')\n\nConsider the following program\n\n '''function''' GenerateProvablyComplexString('''int''' ''n'')\n     '''for''' i = 1 to infinity:\n         '''if''' NthProofProvesComplexityFormula(i) '''and''' ComplexityLowerBoundNthProof(i) \u2265 ''n''\n             '''return''' StringNthProof(''i'')\n\nGiven an ''n'', this program tries every proof until it finds a string and a proof in the [[formal system]] '''S''' of the formula ''K''(''s'')&nbsp;\u2265&nbsp;''L'' for some ''L''&nbsp;\u2265&nbsp;''n''. The program terminates by our '''Assumption (X)'''. Now, this program has a length ''U''. There is an integer ''n''<sub>0</sub> such that ''U''&nbsp;+&nbsp;log<sub>2</sub>(''n''<sub>0</sub>)&nbsp;+&nbsp;''C''&nbsp;<&nbsp;''n''<sub>0</sub>, where ''C'' is the overhead cost of\n\n '''function''' GenerateProvablyParadoxicalString()\n     '''return''' GenerateProvablyComplexString(''n''<sub>0</sub>)\n\n(''n''<sub>0</sub> is hard-coded into the above function, and the summand log<sub>2</sub>(''n''<sub>0</sub>) already allows for its encoding). The program GenerateProvablyParadoxicalString outputs a string ''s'' for which there exists an ''L'' such that ''K''(''s'')&nbsp;\u2265&nbsp;''L'' can be formally proved in '''S''' with ''L''&nbsp;\u2265&nbsp;''n''<sub>0</sub>. In particular, ''K''(''s'')&nbsp;\u2265&nbsp;''n''<sub>0</sub> is true. However, ''s'' is also described by a program of length ''U''&nbsp;+&nbsp;log<sub>2</sub>(''n''<sub>0</sub>)&nbsp;+&nbsp;''C'', so its complexity is less than ''n''<sub>0</sub>.  This contradiction proves '''Assumption (X)''' cannot hold.\n\nSimilar ideas are used to prove the properties of [[Chaitin's constant]].\n\n", "attributes": [{"name": "color", "values": [{"name": "1", "value": "#800000"}, {"name": "2", "value": "''K''(''s'')"}]}, {"name": "color", "values": [{"name": "1", "value": "#808000"}, {"name": "2", "value": "prog1(s)"}]}, {"name": "color", "values": [{"name": "1", "value": "#008000"}, {"name": "2", "value": "prog2(s)"}]}], "id": 11}, {"title": "Minimum message length", "paragraphs": "{{Main|Minimum message length}}\nThe minimum message length principle of statistical and inductive inference and machine learning was developed by [[Chris Wallace (computer scientist)|C.S. Wallace]] and D.M. Boulton in 1968. MML is [[Bayesian probability|Bayesian]] (i.e. it incorporates prior beliefs) and information-theoretic. It has the desirable properties of statistical invariance (i.e. the inference transforms with a re-parametrisation, such as from polar coordinates to Cartesian coordinates), statistical consistency (i.e. even for very hard problems, MML will converge to any underlying model) and efficiency (i.e. the MML model will converge to any true underlying model about as quickly as is possible). C.S. Wallace and D.L. Dowe (1999) showed a formal connection between MML and algorithmic information theory (or Kolmogorov complexity).<ref>{{cite journal |citeseerx=10.1.1.17.321 |title=Minimum Message Length and Kolmogorov Complexity |journal=Computer Journal |volume=42 |issue=4 |pages=270\u2013283 |year=1999 |last1=Wallace |first1=C. S. |last2=Dowe |first2=D. L. |doi=10.1093/comjnl/42.4.270 }}</ref>\n\n", "attributes": [{"name": "Main", "values": [{"name": "1", "value": "Minimum message length"}]}, {"name": "cite journal ", "values": [{"name": "citeseerx", "value": "10.1.1.17.321"}, {"name": "title", "value": "Minimum Message Length and Kolmogorov Complexity"}, {"name": "journal", "value": "Computer Journal"}, {"name": "volume", "value": "42"}, {"name": "issue", "value": "4"}, {"name": "pages", "value": "270\u2013283"}, {"name": "year", "value": "1999"}, {"name": "last1", "value": "Wallace"}, {"name": "first1", "value": "C. S."}, {"name": "last2", "value": "Dowe"}, {"name": "first2", "value": "D. L."}, {"name": "doi", "value": "10.1093/comjnl/42.4.270"}]}], "id": 12}, {"title": "Kolmogorov randomness", "paragraphs": "{{See also|Algorithmic randomness}}\n''Kolmogorov randomness'' defines a string (usually of [[bit]]s) as being [[randomness|random]] if and only if it is shorter than any [[computer program]] that can produce that string.  To make this precise, a [[Universal Turing machine|universal computer]] (or universal Turing machine) must be specified, so that \"program\" means a program for this universal machine. A random string in this sense is \"incompressible\" in that it is impossible to \"compress\" the string into a program whose length is shorter than the length of the string itself.  A [[counting argument]] is used to show that, for any universal computer, there is at least one algorithmically random string of each length.  Whether any particular string is random, however, depends on the specific universal computer that is chosen.\n\nThis definition can be extended to define a notion of randomness for ''infinite'' sequences from a finite alphabet. These [[algorithmically random sequence]]s can be defined in three equivalent ways. One way uses an effective analogue of [[measure theory]]; another uses effective [[Martingale (probability theory)|martingales]].  The third way defines an infinite sequence to be random if the prefix-free Kolmogorov complexity of its initial segments grows quickly enough&nbsp;\u2014 there must be a constant ''c'' such that the complexity of an initial segment of length ''n'' is always at least ''n''\u2212''c''.  This definition, unlike the definition of randomness for a finite string, is not affected by which universal machine is used to define prefix-free Kolmogorov complexity.<ref>{{cite journal |doi=10.1016/s0019-9958(66)80018-9 |title=The definition of random sequences |journal=Information and Control |volume=9 |issue=6 |pages=602\u2013619 |year=1966 |last1=Martin-L\u00f6f |first1=Per }}</ref>\n\n", "attributes": [{"name": "See also", "values": [{"name": "1", "value": "Algorithmic randomness"}]}, {"name": "cite journal ", "values": [{"name": "doi", "value": "10.1016/s0019-9958(66)80018-9"}, {"name": "title", "value": "The definition of random sequences"}, {"name": "journal", "value": "Information and Control"}, {"name": "volume", "value": "9"}, {"name": "issue", "value": "6"}, {"name": "pages", "value": "602\u2013619"}, {"name": "year", "value": "1966"}, {"name": "last1", "value": "Martin-L\u00f6f"}, {"name": "first1", "value": "Per"}]}], "id": 13}, {"title": "Relation to entropy", "paragraphs": "For dynamical systems, entropy rate and algorithmic complexity of the trajectories are related by a theorem of Brudno, that the equality K(x;T) =  h(T) holds for almost all x.<ref>{{cite journal |first1=Stefano|last1=Galatolo |first2=Mathieu|last2=Hoyrup |first3=Crist\u00f3bal|last3=Rojas |title=Effective symbolic dynamics, random points, statistical behavior, complexity and entropy | journal=Information and Computation | volume=208 | pages=23\u201341 | year=2010| url=http://www.loria.fr/~hoyrup/random_ergodic.pdf | doi=10.1016/j.ic.2009.05.001}}</ref>\n\nIt can be shown<ref>{{cite arxiv |author=Alexei Kaltchenko |title=Algorithms for Estimating Information Distance with Application to Bioinformatics and Linguistics  |year=2004 |eprint=cs.CC/0404039}}</ref> that for the output of [[Markov information source]]s, Kolmogorov complexity is related to the [[Entropy (information theory)|entropy]] of the information source. More precisely, the Kolmogorov complexity of the output of a Markov information source, normalized by the length of the output, converges almost surely (as the length of the output goes to infinity) to the [[Entropy (information theory)|entropy]] of the source.\n\n", "attributes": [{"name": "cite journal ", "values": [{"name": "first1", "value": "Stefano"}, {"name": "last1", "value": "Galatolo"}, {"name": "first2", "value": "Mathieu"}, {"name": "last2", "value": "Hoyrup"}, {"name": "first3", "value": "Crist\u00f3bal"}, {"name": "last3", "value": "Rojas"}, {"name": "title", "value": "Effective symbolic dynamics, random points, statistical behavior, complexity and entropy"}, {"name": "journal", "value": "Information and Computation"}, {"name": "volume", "value": "208"}, {"name": "pages", "value": "23\u201341"}, {"name": "year", "value": "2010"}, {"name": "url", "value": "http://www.loria.fr/~hoyrup/random_ergodic.pdf"}, {"name": "doi", "value": "10.1016/j.ic.2009.05.001"}]}, {"name": "cite arxiv ", "values": [{"name": "author", "value": "Alexei Kaltchenko"}, {"name": "title", "value": "Algorithms for Estimating Information Distance with Application to Bioinformatics and Linguistics"}, {"name": "year", "value": "2004"}, {"name": "eprint", "value": "cs.CC/0404039"}]}], "id": 14}, {"title": "Conditional versions", "paragraphs": "{{expand section|date=July 2014}}\nThe conditional Kolmogorov complexity of two strings <math>K(x|y)</math> is, roughly speaking, defined as the Kolmogorov complexity of ''x'' given ''y'' as an auxiliary input to the procedure.<ref name=\"Rissanen2007\">{{cite book|author=Jorma Rissanen|title=Information and Complexity in Statistical Modeling|year=2007|publisher=Springer S |isbn=978-0-387-68812-1|page=53}}</ref><ref>{{cite book|author1=Ming Li|author2=Paul M.B. Vit\u00e1nyi|title=An Introduction to Kolmogorov Complexity and Its Applications|year=2009|publisher=Springer |isbn=978-0-387-49820-1|pages=105\u2013106}}</ref>\n\nThere is also a length-conditional complexity <math>K(x|L(x))</math>, which is the complexity of ''x'' given the length of ''x'' as known/input.<ref>{{cite book|author1=Ming Li|author2=Paul M.B. Vit\u00e1nyi|title=An Introduction to Kolmogorov Complexity and Its Applications|year=2009|publisher=Springer  |isbn=978-0-387-49820-1|page=119}}</ref><ref>{{cite journal |doi=10.1016/j.tcs.2013.07.009 |title=Conditional Kolmogorov complexity and universal probability |journal=Theoretical Computer Science |volume=501 |pages=93\u2013100 |year=2013 |last1=Vit\u00e1nyi |first1=Paul M.B. |url=https://ir.cwi.nl/pub/26818 |arxiv=1206.0983 }}</ref>\n\n", "attributes": [{"name": "expand section", "values": [{"name": "date", "value": "July 2014"}]}, {"name": "cite book", "values": [{"name": "author", "value": "Jorma Rissanen"}, {"name": "title", "value": "Information and Complexity in Statistical Modeling"}, {"name": "year", "value": "2007"}, {"name": "publisher", "value": "Springer S"}, {"name": "isbn", "value": "978-0-387-68812-1"}, {"name": "page", "value": "53"}]}, {"name": "cite book", "values": [{"name": "author1", "value": "Ming Li"}, {"name": "author2", "value": "Paul M.B. Vit\u00e1nyi"}, {"name": "title", "value": "An Introduction to Kolmogorov Complexity and Its Applications"}, {"name": "year", "value": "2009"}, {"name": "publisher", "value": "Springer"}, {"name": "isbn", "value": "978-0-387-49820-1"}, {"name": "pages", "value": "105\u2013106"}]}, {"name": "cite book", "values": [{"name": "author1", "value": "Ming Li"}, {"name": "author2", "value": "Paul M.B. Vit\u00e1nyi"}, {"name": "title", "value": "An Introduction to Kolmogorov Complexity and Its Applications"}, {"name": "year", "value": "2009"}, {"name": "publisher", "value": "Springer"}, {"name": "isbn", "value": "978-0-387-49820-1"}, {"name": "page", "value": "119"}]}, {"name": "cite journal ", "values": [{"name": "doi", "value": "10.1016/j.tcs.2013.07.009"}, {"name": "title", "value": "Conditional Kolmogorov complexity and universal probability"}, {"name": "journal", "value": "Theoretical Computer Science"}, {"name": "volume", "value": "501"}, {"name": "pages", "value": "93\u2013100"}, {"name": "year", "value": "2013"}, {"name": "last1", "value": "Vit\u00e1nyi"}, {"name": "first1", "value": "Paul M.B."}, {"name": "url", "value": "https://ir.cwi.nl/pub/26818"}, {"name": "arxiv", "value": "1206.0983"}]}], "id": 15}, {"title": "See also", "paragraphs": "* [[List of important publications in theoretical computer science#Algorithmic information theory|Important publications in algorithmic information theory]]\n* [[Berry paradox]]\n* [[Code golf]]\n* [[Data compression]]\n* [[Demoscene]], a computer art discipline whose certain branches are centered around the creation of smallest programs that achieve certain effects\n* [[Grammar induction]]\n* [[Inductive inference]]\n* [[Kolmogorov structure function]]\n* [[Levenshtein distance]]\n* [[Solomonoff's theory of inductive inference]]\n\n", "attributes": [], "id": 16}, {"title": "Notes", "paragraphs": "{{Reflist|group=note}}\n\n", "attributes": [{"name": "Reflist", "values": [{"name": "group", "value": "note"}]}], "id": 17}, {"title": "References", "paragraphs": "{{Reflist|30em}}\n\n", "attributes": [{"name": "Reflist", "values": [{"name": "1", "value": "30em"}]}], "id": 18}, {"title": "Further reading", "paragraphs": "* {{cite journal | authorlink=Manuel Blum|last=Blum | title=On the size of machines | journal=Information and Control |first= M. | volume=11 | issue=3 | page=257 | year=1967 | doi = 10.1016/S0019-9958(67)90546-3 }}\n* {{cite journal |first=A. |last=Brudno |title=Entropy and the complexity of the trajectories of a dynamical system |journal=Transactions of the Moscow Mathematical Society |volume=2 |issue= |pages=127\u2013151 |year=1983 }}\n* {{cite book |last=Cover |first=Thomas M. |last2=Thomas |first2=Joy A. |title=Elements of information theory |publisher=Wiley-Interscience |edition=2nd |year=2006 |isbn=0-471-24195-4 }}\n* {{cite book |last=Lajos |first=R\u00f3nyai |last2=G\u00e1bor |first2=Ivanyos |last3=R\u00e9ka |first3=Szab\u00f3 |title=Algoritmusok |publisher=TypoTeX  |year=1999 |isbn=963-279-014-6 }}\n* {{cite book |last=Li |first=Ming  |last2=Vit\u00e1nyi |first2=Paul|title=An Introduction to Kolmogorov Complexity and Its Applications|publisher=Springer |year=1997 |isbn= 978-0387339986 |ref=harv}}\n* {{cite book |first=Manin |last=Yu |title=A Course in Mathematical Logic |publisher=Springer-Verlag |year=1977 |isbn=978-0-7204-2844-5 |url-access=registration |url=https://archive.org/details/courseinmathemat0000bell }}\n* {{cite book |first=Michael |last=Sipser |title=Introduction to the Theory of Computation |url=https://archive.org/details/introductiontoth00sips |url-access=registration |publisher=PWS |year=1997 |isbn=0-534-95097-3 }}\n\n", "attributes": [{"name": "cite journal ", "values": [{"name": "authorlink", "value": "Manuel Blum"}, {"name": "last", "value": "Blum"}, {"name": "title", "value": "On the size of machines"}, {"name": "journal", "value": "Information and Control"}, {"name": "first", "value": "M."}, {"name": "volume", "value": "11"}, {"name": "issue", "value": "3"}, {"name": "page", "value": "257"}, {"name": "year", "value": "1967"}, {"name": "doi", "value": "10.1016/S0019-9958(67)90546-3"}]}, {"name": "cite journal ", "values": [{"name": "first", "value": "A."}, {"name": "last", "value": "Brudno"}, {"name": "title", "value": "Entropy and the complexity of the trajectories of a dynamical system"}, {"name": "journal", "value": "Transactions of the Moscow Mathematical Society"}, {"name": "volume", "value": "2"}, {"name": "pages", "value": "127\u2013151"}, {"name": "year", "value": "1983"}]}, {"name": "cite book ", "values": [{"name": "last", "value": "Cover"}, {"name": "first", "value": "Thomas M."}, {"name": "last2", "value": "Thomas"}, {"name": "first2", "value": "Joy A."}, {"name": "title", "value": "Elements of information theory"}, {"name": "publisher", "value": "Wiley-Interscience"}, {"name": "edition", "value": "2nd"}, {"name": "year", "value": "2006"}, {"name": "isbn", "value": "0-471-24195-4"}]}, {"name": "cite book ", "values": [{"name": "last", "value": "Lajos"}, {"name": "first", "value": "R\u00f3nyai"}, {"name": "last2", "value": "G\u00e1bor"}, {"name": "first2", "value": "Ivanyos"}, {"name": "last3", "value": "R\u00e9ka"}, {"name": "first3", "value": "Szab\u00f3"}, {"name": "title", "value": "Algoritmusok"}, {"name": "publisher", "value": "TypoTeX"}, {"name": "year", "value": "1999"}, {"name": "isbn", "value": "963-279-014-6"}]}, {"name": "cite book ", "values": [{"name": "last", "value": "Li"}, {"name": "first", "value": "Ming"}, {"name": "last2", "value": "Vit\u00e1nyi"}, {"name": "first2", "value": "Paul"}, {"name": "title", "value": "An Introduction to Kolmogorov Complexity and Its Applications"}, {"name": "publisher", "value": "Springer"}, {"name": "year", "value": "1997"}, {"name": "isbn", "value": "978-0387339986"}, {"name": "ref", "value": "harv"}]}, {"name": "cite book ", "values": [{"name": "first", "value": "Manin"}, {"name": "last", "value": "Yu"}, {"name": "title", "value": "A Course in Mathematical Logic"}, {"name": "publisher", "value": "Springer-Verlag"}, {"name": "year", "value": "1977"}, {"name": "isbn", "value": "978-0-7204-2844-5"}, {"name": "url-access", "value": "registration"}, {"name": "url", "value": "https://archive.org/details/courseinmathemat0000bell"}]}, {"name": "cite book ", "values": [{"name": "first", "value": "Michael"}, {"name": "last", "value": "Sipser"}, {"name": "title", "value": "Introduction to the Theory of Computation"}, {"name": "url", "value": "https://archive.org/details/introductiontoth00sips"}, {"name": "url-access", "value": "registration"}, {"name": "publisher", "value": "PWS"}, {"name": "year", "value": "1997"}, {"name": "isbn", "value": "0-534-95097-3"}]}], "id": 19}, {"title": "External links", "paragraphs": "* [https://web.archive.org/web/20180321163508/http://kolmogorov.com/ The Legacy of Andrei Nikolaevich Kolmogorov]\n* [https://web.archive.org/web/20150215210504/http://www.cs.umaine.edu/~chaitin/ Chaitin's online publications]\n* [http://www.idsia.ch/~juergen/ray.html Solomonoff's IDSIA page]\n* [http://www.idsia.ch/~juergen/kolmogorov.html Generalizations of algorithmic information] by [[Juergen Schmidhuber|J. Schmidhuber]]\n* {{cite web  |title=Review of Li Vit\u00e1nyi 1997  |url=http://homepages.cwi.nl/~paulv/kolmogorov.html}}\n* {{cite web |first=John |last=Tromp |url=https://tromp.github.io/cl/cl.html |title=John's Lambda Calculus and Combinatory Logic Playground}} Tromp's lambda calculus computer model offers a concrete definition of K()]\n* Universal AI based on Kolmogorov Complexity {{isbn|3-540-22139-5}} by [[Marcus Hutter|M. Hutter]]:  {{isbn|3-540-22139-5}}\n* [http://www.csse.monash.edu.au/~dld David Dowe]'s [http://www.csse.monash.edu.au/~dld/MML.html Minimum Message Length (MML)] and [http://www.csse.monash.edu.au/~dld/Occam.html Occam's razor] pages.\n* {{cite book |first=P. |last=Grunwald |first2=M.A. |last2=Pitt |editor-first=I. J. |editor-last=Myung |title=Advances in Minimum Description Length: Theory and Applications |publisher=MIT Press |location= |year=2005 |isbn=0-262-07262-9 }}\n\n{{Compression Methods}}\n\n{{DEFAULTSORT:Kolmogorov Complexity}}\n[[Category:Algorithmic information theory|*]]\n[[Category:Information theory|*]]\n[[Category:Computability theory]]\n[[Category:Descriptive complexity]]\n[[Category:Measures of complexity]]", "attributes": [{"name": "cite web  ", "values": [{"name": "title", "value": "Review of Li Vit\u00e1nyi 1997"}, {"name": "url", "value": "http://homepages.cwi.nl/~paulv/kolmogorov.html"}]}, {"name": "cite web ", "values": [{"name": "first", "value": "John"}, {"name": "last", "value": "Tromp"}, {"name": "url", "value": "https://tromp.github.io/cl/cl.html"}, {"name": "title", "value": "John's Lambda Calculus and Combinatory Logic Playground"}]}, {"name": "isbn", "values": [{"name": "1", "value": "3-540-22139-5"}]}, {"name": "isbn", "values": [{"name": "1", "value": "3-540-22139-5"}]}, {"name": "cite book ", "values": [{"name": "first", "value": "P."}, {"name": "last", "value": "Grunwald"}, {"name": "first2", "value": "M.A."}, {"name": "last2", "value": "Pitt"}, {"name": "editor-first", "value": "I. J."}, {"name": "editor-last", "value": "Myung"}, {"name": "title", "value": "Advances in Minimum Description Length: Theory and Applications"}, {"name": "publisher", "value": "MIT Press"}, {"name": "year", "value": "2005"}, {"name": "isbn", "value": "0-262-07262-9"}]}], "id": 20}]}